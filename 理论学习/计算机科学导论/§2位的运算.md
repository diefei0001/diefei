# 进制转换
> 任意进制转换十进制，只需要计算`原有进制的数码乘以对应的位置量的积的和`即可
![alt text](diefei\Markdown素材库\Markdown 素材\R进制转十进制.png)
> 十进制的整数部分向其他进制的转换主要使用连除法,要经过如下流程:
![alt text](diefei\Markdown素材库\Markdown 素材\连除法.png)
![alt text](diefei\Markdown素材库\Markdown 素材\连除法_底除源.png)
> 十进制的整数部分向其他进制的转换主要使用连乘法,要经过如下流程:
![alt text](diefei\Markdown素材库\Markdown 素材\连乘法.png)
![alt text](diefei\Markdown素材库\Markdown 素材\连乘法_底乘源.png)
> 由于二进制的四位正好等于十六进制的一位,因此我们将这样转换:
![alt text](diefei\Markdown素材库\Markdown 素材\2与16互换.png)
> 二进制的三位正好等于八进制的一位，因此我们将这样转换：
![alt text](diefei\Markdown素材库\Markdown 素材\2与8进制互换.png)
> 八进制和十六进制的互换依赖二进制为中介：
![alt text](diefei\Markdown素材库\Markdown 素材\8与16互换.png)
*如果位数不够,整数在最左边补零，小数部分在最右边补零*

# 数码的最大最小值的问题
> 限定数码位数下的最大值：
- 对于一个使用k个数码，以b为底的数码系统，其最大值为：
b_{1}^{k} -1
> 一个小于b的k次方的数，其可以被b为基底，k个数码表示。
> 进制转换的最小值问题
源数码系统以b1为基底，使用k个数码，则转换为宿数码系统，至少需要`k*（logb1/logb2）`个数码
# 位模式层次的逻辑运算
> 四种逻辑运算的规则
- `Not`运算：取相反值
- `AND`运算：同时为1才为1
- `Or`运算： 同时为0才为0
- `Xor`运算：相同为假，不同为真
> 四种逻辑运算的实际运用
- 求反是[将整个位模式的每一个位都取反值]
- 置位和复位分别[将特定位变为1或0，用于实现置位和复位的位模式被称为相对于另一个位模式的掩码]。
- XOR实现[位模式的部分取反]

# 移位运算
> 逻辑移位&循环移位
- 逻辑移位将位模式的一侧端点的位舍弃，从另一端补充0；循环移位将一侧端点的位添加到另一侧端点
> 算术移位运算
- 算术[右移复制符号位，舍弃最低位]，算术[左移舍弃符号位，新的最高位成为符号位，并在最低位添加0]
> 移位运算的本质
移位运算的本质是改变了数码对应的位置量，根据位权展开式，位置量是公比为2的等比数列。因此在逻辑移位和算术移位中，[数码左移一次相当于乘一次2，右移一次相当于除一次2]。
# 二进制加法
> 基本原理
- *1+0 =1* 
- *0+0 =0*
- *1+1 = 10*
- 例如：
	 进位：1 1 1 1
           1 1 1 1 （15）
         + 1 1 1 1 （15）
         ------------
         1 1 1 1 0 （30）

> 二进制补码的加减
- 二进制补码中，被减数可以通过取反加一得到对应的负数，进而转换成正数+负数
- 在二进制补码格式的整数相加中，最左边一列的进位被忽略。这是因为补码表示中，最左边一位是符号位，用来表示整数的正负。如果最左边一列有进位，那么表示结果溢出。
> 固定位系统的二进制加法溢出问题
- 固定位系统的表示范围是有限的，当二进制加法发生溢出（即超出固定位系统的位数），
- 则多余位被舍弃，例如：
    进位：1 1 1 1 1 1 1 1
            1 1 1 1 1 1 1 1
          + 0 0 0 0 0 0 0 1
          -------------------
           0 0 0 0 0 0 0 0 0
  可以看到1被舍弃了
