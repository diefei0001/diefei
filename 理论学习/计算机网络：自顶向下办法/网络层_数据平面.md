# IPv4协议
> IP协议的功能是规范了数据平面的转发
## IPv4 datagram的格式
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   版本 (4)    |  IHL (头长度)  |   服务类型 (TOS)   |        总长度        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             标识 (Identification)             | 标志位 |  分片偏移 (Fragment Offset)  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    生存时间 (TTL)    |   协议 (Protocol)     |        头部校验和 (Header Checksum)       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       源 IP 地址 (Source Address)                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     目的 IP 地址 (Destination Address)                 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            选项 (Options) (如果有)                     |
|                             ...                                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                                    |
|                           数据 (Data / Payload)                    |
|                                                                    |
|                                                                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
> IPv4数据报存在20字节的固定头部
> 20字节的固定长度分别包含：版本，THL，TOS，总长度，ID，标志位，分片偏移，TTL和协议，头部校验和，源IP目标IP
  1. 版本号：ipv4（ipv6格式不同）
  2. THL：最小值5，最大值15（以4个字节为一个单位）
  3. TOS：原本是用于分组优先级调度的，后因商业模式弃用
  4. 长度：与传输层报文一致，代表数据报总长
  5. 标识，标志位，分片偏移都是用于分组分片
  6. TTL：存活时间，每经过一个路由器减一，防止分组在网络环路转发
  7. 协议：该分组来自哪个协议，来自上层哪个协议实体
  8. 头部checksum：头部校验和，判断头部是否有问题
.
---------------------------------------------------------------------------------------------
## IPv4编址
### IP地址概念
> IP地址是对主机或路由器接口的32位标识符，格式是点分十进制计法，三十二位被分为网络部分和主机部分
### 子网
> 根据网络前缀，可以划分出不同的子网，子网内的设备通信无需路由器
- 前缀相同的ip地址为一个子网，相当于是将网络进行了划分成若干个小网络。例如一个C类地址：192.168.1.x，只要前三个字节是一样的，那么就说明它们处于同一子网
> 通常一个子网的设备集中连接到路由器的一个端口
### 特定IP地址
网络地址：主机位全0，用于标识子网
广播地址：主机位全1，用于在子网广播
环回地址：127.x.x.x
### 公网与内网
> 公网是全球互联的公共网络，公网IP不能重复
- 公网就是传统语境下的互联网，公网ip不能重复
> 内网ip从全球IPv4地址空间中“保留”出一部分特殊地址段，只在局域网内部有意义，由路由器映射到公网范围内
A类保留：10.0.0.0/8（原属A类大地址块）
B类保留：172.16.0.0/12（覆盖16个B类网络）
C类保留：192.168.0.0/16（覆盖256个C类网络）
### 分类编址
- 网络部分为8个字节的网络称为`A类网络`，A类地址的最高位置零，可用范围为1-126，网络部分为16个字节的网络称为`B类网络`，B类地址的最高两位10，可用范围为128-191，网络部分为24个字节的网络称为`C类网络`，最高位置110，可用范围为192-255.
- D类地址的前缀是1110，是组播地址
- E类地址预留
### CIDR（无类域间路由）
> 分类编制缺陷
- 由于我们知道，A，B类地址数量虽多，但实际上只用掉了一部分，而C类又太少，导致了[ipv4地址的枯竭]
- 同时转发决策（查路由表）的依据是目标地址所属的子网（网络前缀），因此每一个C类网都需要单独的一个条目，这就导致[路由条目过多]，查找效率过慢；
> CIDR废除了ABC类网络的分类，通过明确网络前缀长度，格式为/<前缀长度>，实际上代表一个ip数据块
- CIDR表示法[给出任何一个IP地址，就相当于给出了一个CIDR地址块]，这是由连续的IP地址组成的，所以CIDR表示法构成了超网，实现了路由聚合，即从一个IP地址就可以得知一个CIDR地址块。
  例如：已知一个IP地址是：128.14.35.7/20，那么这个已知条件告诉大家的并不仅仅是一个IP地址这么简单，我们来分析一下。
  128.14.35.7/20 = 10000000  00001110  00100011  00000111
  即前20位是网络前缀，后12位是主机号，那么我们通过令主机号分别为全0和全1就可以得到一个CIDR地址块的最小地址和最大地址，即
  最小地址是：128.14.32.0      = 10000000  00001110  00100000  00000000
  最大地址是：128.14.47.255  = 10000000  00001110  00101111 11111111
  子网掩码是：255.255.240.0  = 11111111  11111111  11110000  00000000
  因此就可以看出来，这个CIDR地址块可以指派(47-32+1)*256=4096个地址，这里没有把全0和全1除外。
> 地址块大小：一个CIDR块包含 2^(32 - 前缀长度) 个IP地址。
示例：10.0.0.0/8 → 地址数 = 2^(24) = 16,777,216。
示例：192.168.1.0/24 → 地址数 = 2^8 = 256。
> 子网掩码是一个 32 位的数字，其中网络前缀部分全为 1，主机部分全为 0。其作用是与ip地址按位与运算判定ip所属的子网
- 在CIDR中，[前缀长度n直接对应子网掩码]，例如/24的掩码为255.255.255.0。
> CIDR通过借位主机位的方法划分子网
- 什么是借位主机位呢？：

              原始：  11000000.10101000.00000000.00000000  /24
              借2位： 11000000.10101000.00000000.00 000000 → /26
                      ↓        ↓        ↓        ↓
              子网1： 192.168.0.0/26   (00 000000 - 00 111111) → 0-63
              子网2： 192.168.0.64/26  (01 000000 - 01 111111) → 64-127
              子网3： 192.168.0.128/26 (10 000000 - 10 111111) → 128-191
              子网4： 192.168.0.192/26 (11 000000 - 11 111111) → 192-255

- 我们观察这个过程，会发现[/24的子网被划分为了4个更小的子网]，其向主机部分借两位作为网络部分，这两位一共可以有4个组合，每个组合都是64种可能；
              原始：  11000000.10101000.00000000.00000000  /24
              借2位： 11000000.10101000.00000000.00 000000 → /27

              子网1： 192.168.0.0/27 （000 00000 - 000 11111） → 0-32
              子网2： 192.168.0.32/27 ；子网3：192.168.0.64/27 ；
也就是说，[借走n个主机位就可以将自身划分2的n次方个子网]
> 常见划分：
前缀长度	                地址块大小	    典型用途	          示例	        数量（块）
/0	                    4,294,967,296	  整个IPv4空间	      0.0.0.0/0	      1
/8	                    16,777,216	    传统A类网络	        10.0.0.0/8	    256
/16	                    65,536	        传统B类网络	        172.16.0.0/16	  65,536
/24	                    256	            标准局域网子网	     192.168.1.0/24	16,777,216
/30	                    4	              点对点链路	        203.0.113.4/30	1,073,741,824
/32	                    1	              单台设备	          203.0.113.1/32	4,294,967,296
> CIDR的本质是将IP地址空间以完全二叉树的形式进行划分：
CIDR	地址块大小（IP地址数）	数量（子网总数）
/24	  256	                  16,777,216
/25	  128	                  33,554,432
/26	  64	                  67,108,864
/27	  32	                  134,217,728
/28	  16	                  268,435,456
/29	  8	                    536,870,912
- 我们不难发现地址块大小被不断二分，而数量在乘2递增。实际上就是将42亿进行32次递归2分，直到变成1.
> CIDR地址空间的快速计算：
- 对于一个/n（n＞24）的地址空间，设H=32-n ，S = 2^H ,D为第四位数字，则
    网络地址为：（D//S） * S
    广播地址为：网络地址+S-1
> 实际举例：
- 假设某公司获得了一个地址块：244.12.34.0/24 ，请将其划分给IT，策划，运营，市场，公关五个部门，其中IT部门需要至少90个ip，策划需要至少60个ip，公关至少需要7个ip，请设计划分方案
  - 首先，该公司获得的地址块范围为：244.12.34.0 到244.12.34.255，一共256个
  - 因为IT部门至少要90个，所以我们能确定该地址块应该是/25；策划需要至少60个，地址块是/26 ，公关7个，/28
  - IT部门显然应该是：244.12.34.0/25 共128个
  - 策划应该是/24分出的两个子网中再分一次，应该是244.12.34.128/26
  - 公关应该是：244.12.34.192/28
  - 此时还剩（208 -255）
.
--------------------------------------------------------------------------------------------
## NAT技术与NAT穿透
> 内网通过NAT技术访问公网
- 路由器处理出公网的分组时，[将内网设备的私有IP，设备端口转换为到路由器的公网IP，路由器的端口] ，并记录端口映射关系。
- 路由器处理进内网的分组时，[将公网来的分组的IP，端口根据映射表，换为内网IP，设备端口]
> NAT只允许内网设备访问公网，来自公网的访问需要NAT穿透或Upnp协议
.
---------------------------------------------------------------------------------------------
## IP数据报分片与重组
### 分片重组概念
> IP分片出现在输出的数据报大小超出传播链路的MTU时
- 为什么会出现输出端口的数据报大小超出传播链路的MTU这种情况呢？我们在之前学习过网络的结构，[路由器往往处于网络核心]，而连接网络核心与网络边缘的`最后一公里链路`处于接入网.[接入网与网络核心是异构的]，因为网络核心的[吞吐量和链路传输速率，所使用的介质（通常是光纤）都与接入网不同，且相差甚远]。同时接入网的各种技术繁多，[各自支持的MTU也不一样]，例如以太接入网的MTU通常是标准的1500，但是基于调制解调的PPPoE的MTU常为1494，而WIFI的MTU为2304.[MTU的差异导致分片的出现]
> 重组由目标主机的网络层执行，按序重组后提交给上层协议
### 分片过程
> 检查DF标志，如果为1，则丢弃
- 分片前会检查DF标志位，如果设置为1，分组会被丢弃并发送ICMP
> 根据出接口链路的MTU，确定分片大小，分片大小总是8的整数倍  
- [确保分片加ip数据头小于等于MTU]
> 给每个分片分组都加上IP头，形成分片
IP头的设置：
  1. `MF =1/0`（取决于还有没有分片）
  2. `FO = 0`或(`原始数据报中当前分片数据的起始位置`) / 8。[FO本质是0为首项的，公差为分片大小/8的等差数列]
  3. `ID：`与原分组一致，分片共享分组的ID
  4. `DF=0 `
- 其他的需要根据分片重新设置
### 重组过程
> 创建/查找重组缓冲区
- 主机为每一个被分片的数据报创建一个重组缓冲区
> 根据字段分别分片是否来自同一数据报
- 使用数据报头中的 Identification、源 IP 地址、目的 IP 地址 和 协议 (Protocol) 字段唯一标识该分片
属于哪个原始数据报
> 通过FO确定分片顺序
- 将分片的数据部分（不包括 IP 头部）放入重组缓冲区中正确的位置。位置由 Fragment Offset * 8 字节确定。
> 如果分组的分片丢失或超时，则其他分片也会被丢弃
- 主机通过MF判断分片的数量
> 重组后，重新生成分组的IP头部，传递给上层
.
---------------------------------------------------------------------------------------------
# IPv6协议
## IPv6地址
> Ipv6地址是128位的标识符
- IPv6地址采用`冒号分十六进制表示法`
## IPv6 dategram
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Version (4)  | Traffic Class |           Flow Label          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Payload Length        |  Next Header  |   Hop Limit   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
|                                                               |
+                         Source Address                        +
|                                                               |
+                                                               +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
|                                                               |
+                      Destination Address                      +
|                                                               |
+                                                               +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
> IPv6的头部固定为40字节
> 20字节的固定长度包括版本，流量类，流标签，下一首部，有效载荷长度，跳数限制，源地址，目标地址。
- 我们只重点提`流标签`，`下一首部`，其他都能在IPv4中找到相似字段。
  下一首部：[标识紧跟在IPv6基本头部之后的数据类型],可能是上层协议，也可能是ipv6拓展，也就是说，相较于ipv4，其option是独立在头部之外的
  流标签：[用于标识需要路由器进行特殊处理（如特定服务质量或实时服务）的连续数据包序列]
> IPv6数据报不分片，分片交由源主机做
### 从ipv4到ipv6的迁移
- TCP协议的实施采用的是革命式的形式，也就是整个网络停掉，升级成TCP协议，但是在网络数量与网络作用日益发展的今天，采用这样的革命方式显然是不可行的
> 使用ipv6通信的网络通过隧道实现与ipv6网络的连接
- 在一片ipv4的海洋里，有ipv6的孤岛，ipv6分组通过批ipv4的皮，来实现传输到另一个ipv6孤岛。这个技术被称为隧道技术。随着ipv6的不断普及，孤岛会变大，海洋会变小，海洋反而成了孤岛！
.
--------------------------------------------------------------------------------------------
# ARP协议
> ARP协议是解决二层寻址的网络地址解析协议
- 在一个典型网络拓扑中，端系统是存在于子网当中的，子网属于局域网。局域网内部通信不依靠IP地址，而是MAC地址。那么[在子网内进行通信需要将IP地址转换为MAC地址，这个工作由ARP协议完成]
> ARP协议维护存储IP地址和MAC地址的映射关系的ARP高速缓存表
## ARP流程
> 查找高速缓存&发送请求报文
- 当本主机向目标IP发送IP数据报，本主机会[查询ARP高速缓存，如果存在Mapping，则直接使用，如果没有，则发送ARPrequest报文，该报文被封装在广播帧中发送]
> 缓存&响应报文
- 子网内的所有设备都会接收到请求报文，[只有IP与自身IP一致的设备会响应该请求，其他的设备会忽略该报文]。如果是PC，则返回自身MAC地址，如果是路由器端口，则返回端口MAC地址；
- 同时，[响应方也会存储该mapping进自己的arp高速缓存]
> 免费ARP是目标地址为自身地址的ARP广播帧，用于IP地址冲突检测
- 我们在DHCP中学习过，当DHCP请求方收到DHCP服务器的ACK报文后，通常还需要发送免费ARP进行IP地址冲突检测。实际上不难理解，如果有人响应这个ARP，那就证明IP地址已经被占用了
## ARP帧结构
┌──────────────────────────┬──────────────┬──────────────────────────┐
│      以太网帧头部         │  ARP报文      │  帧校验序列 (FCS)        │
│   (14字节)               │ (28字节)      │  (4字节)                 │
└──────────────────────────┴──────────────┴──────────────────────────┘
```
### 以太网头部 (14字节) ###
FF FF FF FF FF FF     # 目的MAC（广播）
00 1A 2B 3C 4D 5E     # 源MAC
08 06                 # EtherType = ARP (0x0806)

### ARP报文 (28字节) ###
00 01                 # 硬件类型 = 以太网 (1)
08 00                 # 协议类型 = IPv4 (0x0800)
06                    # 硬件地址长度 = 6
04                    # 协议地址长度 = 4
00 01                 # 操作码 = 请求 (1)
00 1A 2B 3C 4D 5E     # 发送方MAC
C0 A8 01 0A           # 发送方IP = 192.168.1.10
00 00 00 00 00 00     # 目标MAC = 全0（未知）
C0 A8 01 14           # 目标IP = 192.168.1.20

### 帧校验序列 (4字节) ###
12 34 56 78           # CRC校验值（由网卡计算）
```
.
---------------------------------------------------------------------------------------------
# ICMP协议
> ICMP是IP协议差错控制机制
> ICMP原理：
A[诊断命令] --> B[构造特定ICMP报文] --> C[发送到目标] --> D[解析ICMP响应] --> E[输出人类可读结果]
## ICMP应用场景
> 确认IP包是否正确到达目标地址
- 例如ping命令就是通过发送ICMP报文，检测对方是否应答
> 通知IP包被丢弃的原因
- 例如IP包在路由器中由于各种原因（缓冲区溢出，TTL耗尽）被丢弃时，会向源主机发送ICMP报文
## ICMP 报文格式
> ICMP的重要字段是Type和Code
偏移	字段	长度	说明
0	Type (类型)	1字节	标识ICMP消息类型（关键字段）
1	Code (代码)	1字节	细分类型下的子状态
2-3	Checksum (校验和)	2字节	整个ICMP报文的校验和
> Type 常见值：
0：Echo Reply（ping响应）
3：Destination Unreachable（目标不可达）
5：Redirect（重定向）
8：Echo Request（ping请求）
11：Time Exceeded（超时）
> Code 示例（Type=3时）：
0：网络不可达
1：主机不可达
3：端口不可达（重要！用于防火墙过滤）
.
--------------------------------------------------------------------------------------------
# 数据平面转发原理
> 分组从源主机发出后，每台路由器都要经历“查路由表→确定下一跳→ARP解析→转发”的循环。这个过程中CIDR决定了路由表的结构，ARP解决链路层寻址，ICMP则处理各种异常情况
## 路由表结构
> 路由表是包含目标地址，子网掩码，下一跳的映射表
> 缺省路由是des为0.0.0.0，mask 为0的默认路由条目
- 如果在路由表内未找到对应的路由条目，路由器则会将该分组丢弃。缺省路由则是在未匹配的情况下， 对分组的默认转发条目。根据LPM算法，其前缀最短，因此优先级最低
> 特定路由是mask 为32的最优路由条目
- 同理，根据LPM算法，其前缀最长，优先级最高。
### CIDR与路由聚合
> CIDR决定了路由表的结构和查询方式
- CIDR[提供的是一个网络范围]，路由表建立的是[该范围到下一跳/出接口的ip地址的映射]。
> 路由聚合可以实现路由表的压缩
- [路由聚合指的是将多个连续的较小前缀合并为一个更大的前缀]。
- 例如：以下4个连续/24网络：
                192.168.0.0/24, 192.168.1.0/24, 192.168.2.0/24, 192.168.3.0/24
- 可聚合为单个/22前缀：192.168.0.0/22,因为它们的前22位都是相同的。它们[从前缀树的根走到支的路径的前22层都是一样的。]
### LPM算法
- 事实上，路由聚合存在路由重叠问题，因为上述四个/24网络不止前22位相同，前21位也相同。路由表存在多个可匹配项时，会采用`最长前缀匹配法`。
> 网络前缀越长，地址块就越小，越短则越大。
- CIDR中，网络前缀变长，地址块不断除2，数量则不断乘2.因此网络前缀越长，也就越接近目标
### 分组转发核心循环
我们来看一个典型的分组转发过程：
`Host A -> R1 (网关)：`
Host A：目标IP不在本地子网 -> 封装目标MAC = 网关R1的MAC (通过ARP获得)。
R1：收到帧 -> 解封装 -> LPM查表 -> 下一跳 = R2的IP -> ARP解析R2的MAC -> 重封装 (Src MAC=R1, Dst MAC=R2) -> 从出接口转发。
`R1 -> R2：`
R2：收到帧 -> 解封装 -> LPM查表 -> 下一跳 = R3的IP -> ARP解析R3的MAC -> 重封装 (Src MAC=R2, Dst MAC=R3) -> 转发。
`R2 -> R3 (最后一跳)：`
R3：收到帧 -> 解封装 -> LPM查表 -> 目标网络直连 (e.g., 10.1.1.0/24 -> eth0) -> ARP解析 Host B的MAC -> 重封装 (Src MAC=R3, Dst MAC=Host B) -> 从eth0转发到本地子网。
`R3 -> Host B：`
本地交换机根据MAC地址表将帧送达Host B。
> 我们只关注两个问题：为什么需要多次ARP？
答：因为输出端口要对输出分组进行`链路层封装`。