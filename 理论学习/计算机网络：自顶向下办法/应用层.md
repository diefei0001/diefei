# 应用层原理
## 网络应用的体系结构
> 常见的体系结构有C/S，P2P，混合模式
- 在C/S模式中，服务器拥有`固定的IP和周知的端口`，一直保持运行，`等待`客户端（client）向其发送请求。
- P2P中的每个节点[既向别的节点请求资源，又根据自身拥有的资源，向别的节点提供资源。],新peer带来新的服务请求，也带来新的服务能力。
- 即时通讯是混合模式的一个例子，上线向服务器报告属于集中式（C/S），两个用户通信则是P2P模式
> 网络层的进程进行通信依靠报文（message）进行通信
- 发起通信请求的进程称为客户端进程，响应通信请求的进程称为服务器进程
- 在P2P模式中，peer既是客户端又是服务器，但是在会话上，也有客户端和服务器之分
## 网络层的进程
> 网络进程通信需要解决一系列问题
- `进程标识`与`寻址`问题
- 传输层提供服务的`SAP`和`原语`问题
- 服务用户`如何使用服务`问题
- 信件传递是一个很好的类比，通信双方需要知道对方的名字（`唯一标识`）和`地址`。[进程标识和寻址问题]需要知道信件应该投入哪个信筒（`SAP`），需要明确是以邮件投递的方式（`原语`）进行传递信息[SAP和原语问题]在信封上，需要写邮编，写地址.信的内容也有具体的格式[如何使用服务]
> 进程通过`ip地址`和`端口号`标识自己和地址

> 传输层通过层间界面的socket（sap）和应用进程接口（原语）向应用层提供服务

> 应用进程如何使用服务
- 应用进程穿过层间接口，需要携带`SDU`+`自己的IP+TCP（UDP）端口`+`对方的IP+TCP（UDP）端口`，拥有这些信息，传输层才能进行封装。
- [应用进程通过socket套接字与对方应用进程进行通信]，socket就像是游戏《protal》里蓝黄传送门一样，报文从蓝色传送门进入，会从黄色传送门出来。
- 应用进程还需要[定义应用层协议：报文格式，解释，时序等，编制应用程序]
## 传输层提供服务的指标
> 传输层提供服务的指标包括：`数据丢失率`，`延迟`，`吞吐`，`安全性`
- 丢失率关联[可靠性]，指的是数据是否会丢失，丢失后是否重传
- 延迟顾名思义，就是[传输信息所需的时间]
- 吞吐是数据的有效传递的量
- 安全性强调数据的私密性
> 不同的网络应用对传输层提供服务的指标的关注/在意程度不同
- 有的[文件类应用，例如电子邮件，对丢失率敏感]；有的[多媒体应用，例如语音与视频，对延迟较为敏感]，称为`时延敏感应用`；[多媒体应用还要求最低吞吐量，以保证应用正常运行]
- 因此应用根据自己的需求选择TCP和UDP,如果对安全敏感，可以采用SSL，SSL能加强TCP的安全性，类似于HTTPS相较于http。
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
> TCP套接字是4元组的一个具有本地意义的标识，代表进程通信的会话关系
- 进程进行TCP通信期间，如果每次[发送数据都要携带如此冗长的层间接口信息，不仅麻烦，而且容易出错]。事实上，[TCP/UDP socket会将这些信息转换为一个socket值（整数）]，使通过层间的信息最小，值得注意的是，这个[socket是本地标识]，仅为了方便操作系统进行管理
> UDP套接字是2元组的标识，代表源IP，源端口
- 由于UDP套接字不包含目标端口目标IP，因此使用UDP进行通信[需要提供SDU，UDP套接字，目标IP和目标端口]，而使用TCP套接字，[只需要提供SDU，TCP套接字]即可。TCP套接字类似于向经常发快递的朋友寄件时用到的身份码，这个身份码包含寄件人，寄件地址和收件人，收件地址等信息，那么你寄件的时候，只需要提供货物（SDU）和身份码即可。UDP套接字类似于向不经常发快递的朋友寄件，身份码只包含寄件人和寄件地址，因此你需要向快递员提供收件人和收件地址。
- 示意图：
  ![alt text](diefei\Markdown素材库\Markdown 素材\TCP socket.png)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Web和Http
## Web
> Web页是由包含若干对象的URL的基本Html文件
> URL格式
                                                       `协议名——用户——口令——主机名——路径名——端口`
- 我们在输入URL时，不少都是默认的，例如端口
> Web是最典型的C/S模式，浏览器是客户，Web服务器是服务端
- 浏览器最重要的部分是渲染引擎，也就是内核，负责将Web服务器发送的对象进行渲染成一个完整的网页
## Http
> 超文本传输协议是Web的应用层协议
- 不同的浏览器可以访问同一个Web服务器，这是因为它们都遵守Http协议
> Http协议建立在TCP之上，端口是80
- 步骤：
  1. 建立连接，TCP三次握手
  2. 发送Http请求报文
  3. 服务器处理请求
  4. 服务器返回Http响应报文
  5. 关闭/保持TCP连接
- `http示意图（非持久性）`：
  ![alt text](diefei\Markdown素材库\Markdown 素材\非持久性Http.png)
  ![alt text](diefei\Markdown素材库\Markdown 素材\非持久性Http（2）.png)
## 响应时间模型
> 往返时间rtt（round-trip time）是分组从客户端到服务器，再回到服务器的时间，其中建立TCP需要一个Rtt，http的发送和响应需要一个Rtt，因此，传输一个文件需要2Rtt+传输时间
- 示意图：
- ![alt text](diefei\Markdown素材库\Markdown 素材\Rtt.png)
## 持久性Http与非持久性Http
> Http 可以分为持久Http和非持久http，Http1.0使用非持久http，Http1.1使用持久gttp
- 所谓非[持久http，也就是一次tcp建立传输一个对象]，下载多个对象需要建立多次TCP。而[持久Http则可以实现多个对象在一个TCP上传输]，二者的[区别就在于第五步是关闭还是保持TCP连接]
- [非持久性http传输一个文件至少需要2个Rtt]，同时重新建立TCP需要消耗资源
- 持久性http[省去了后续建立TCP连接的繁琐步骤，并且可以使用流水线技术]。非流水线Http顺序执行多个对象的请求和响应任务，[客户端只能在收到前一个响应后才能发出新的请求]。流水线Http[遇到一个对象请求就立马发送，而无需等待上一个请求被响应]
## Http报文
> Http请求报文可以分为`请求`和`响应`两种
> Http报文是ASCII格式的英文进行书写
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
> Http请求报文的通用格式：
- 总体来说，可以分为`请求行`，`首部行`，`实体`。
`示意图`：
![alt text](diefei\Markdown素材库\Markdown 素材\Http请求报文通用格式.png)
> Http响应报文的通用格式：
- 总体来说，可以分为`状态行`，`首部行`，`数据`
`示意图`：
![alt text](diefei\Markdown素材库\Markdown 素材\Http响应报文通用格式.png)
## 无状态与cookies
> Http是无状态的连接，其不记忆来自客户的上次请求
- 无状态指的是[客户端与服务器的每次通信都是独立的，服务器不会保存客户端的上下文信息]（如登录状态、操作步骤等）。这样的[优点是减少服务器的计算资源的开销，并且提高服务器的并发能力]，[缺点自然是无法支持需要连续交互的场景]
> cookies解决http无状态的无法维护客户端状态的问题.，cookies存在三个位置：`响应报文`，`请求报文`，`端系统`，`后端数据库`
- 当一个端系统请求一个从未请求过（或是手动清除cookie）的web服务器时：
   [web服务器会在响应报文添加cookie首部行] → [保留该客户的cookie在后端数据库] → [客户收到cookie后，将其存在端系统中] → [客户再次访问web服务器，请求报文带上cookie的首部行]
- 示意图：
![alt text](diefei\Markdown素材库\Markdown 素材\Cookies.png)
> cookies的缺点是可能涉及信息泄露与个人隐私问题等
## Web缓存（代理服务器）
> Web服务器可以设置Web缓存，允许客户不直接访问原始服务器从而获得数据
- 当客户向Web服务器请求时，如果Web缓存有，则直接返回，没有则向原始服务器请求。 类似于CPU里的cache memory，其存放着CPU常用的内存数据的副本。[client向Web缓存请求，如果成功返回，那么被称为`命中`]
> Web缓存降低了Web服务器的负载，降低了网络的消耗
- 互联网访问具有趋同性，因此在很小的缓存中，都能有很高的命中率
> Web缓存通过条件Get查询数据是否更新
- 另一个问题是，如何保证Web缓存数据的时效性？方法是，当客户请求数据时，Web缓存向Web服务器发送condition Get，即发送if modified since <date>。如果没更新就返回信息：304 not modified ，更新了就返回新文件
# Ftp
# Email/SMTP/POP3/IMAP
# DNS
# P2P
# CDN
# TCP套接字编程
# UDP套接字编程