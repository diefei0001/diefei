# 传输层原理
> 传输层向上提供的服务是以`应用进程`之间的，以报文为单位的，水平层面的逻辑通信
- 之前讲解应用层时，对传输层已经有所提及。理解了互联网的分层后，应该不难理解这个服务为什么是`逻辑`的。
## 报文分段机制
> 传输层将来自应用层的报文（message）分为若干段，每段加上段头构成本层的PDU——报文段（message segment）
- TCP和UDP的切割方法不同，后续会提及
## 面向字节流和面向报文
> 传输层的核心协议是TCP和UDP，其中TCP是面向字节流的数据传输,UDP是面向报文的传输
- [面向字节流是TCP的一个重要的特点]，那么这个所谓的`面向字节流`是什么呢？面向字节流的特点是：`基于字节划分`，`无消息边界`，`有序可靠传输`:
  - TCP之所以称为面向字节流，关键在于[其报文段是基于字节，根据MSS的大小进行划分的]。
  - TCP不维护消息边界，意思就是客户端通过多次write/send（）写入发送数据，服务器端通过recv（）和read（）看到的，[不是独立的片，而是连续的字节序列]。也就是说，[TCP不记录应用层写入数据的次数和语义边界。它只负责把发送方写入的所有字节按MSS的大小分割，然后顺序、可靠地传输到接收方的缓冲区],就像是水管里的水，水龙头多次开关，即使每次传输的水量不同，间隔也不同，但是水顺着水管到达接水的盆子，其并不会被分割，而是连续的
  - UDP则完全相反，[其保留消息边界，多次传输之间的数据是完整的独立的]，而不像TCP那样被排成一个字节序列.
    - 一个形象的比喻是，假如A向B发送2篇文章一共100个字，其中A文章3段发三次，B文章2段发两次。如果使用TCP来发，B接收到的是一共100个字的队列，而使用UDP来发送，则B接收到的就是5个段落
  - 有序可靠传输指的是[TCP通过序号维护分组顺序，通过超时重传机制提供可靠性]


## 传输层对网络层的加强
> 传输层加强了网络的服务品质,但其不保证延迟和带宽
- 网络层提供的服务是不可靠的，[传输层加强了其可靠性]。但是传输层无法加强延迟，带宽，吞吐量等问题。
# 多路复用与解复用
> 内核提取socket的信息，与来自上层的SDU一起封装成PDU
- 我们知道来自应用层的协议实体通过Socket api的方式使用传输层提供的服务，同时也学习过Socket在实现数据传输接口的同时，维护一个4元或2元的，存储着ip，端口，pid等信息的表，结合下列`TCP与UDP的头部`：

   0                   1                   2                   3   
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Source Port          |       Destination Port        | → 四元组核心
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Sequence Number                        | → 数据字节流的起始序号
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Acknowledgment Number                      | → 期望收到的下一个字节序号（ACK）
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Data |           |U|A|P|R|S|F|                               |
| Offset| Reserved  |R|C|S|S|Y|I|            Window             | → 窗口大小（流量控制）
|       |           |G|K|H|T|N|N|                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Checksum            |         Urgent Pointer        | → 校验和/紧急指针
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options (if Data Offset > 5)               | → 可选字段
|                             ...                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Data                              | → 应用层数据
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                           `TCP头部`
 0                   1                   2                   3   
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Source Port          |       Destination Port        | → 四元组核心
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Length             |           Checksum            | → 总长度/校验和
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Data                              | → 应用层数据
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                            `UDP头部`
  -  [SourcePort和DestinationPort都来自socket,它们长16bit];
- 通过观察头部我们不难发现，在[传输层实际上只封装端口]，IP的封装是网络层的职责，传输层会将源ip和目标ip交给网络层封装IP层的头部
> TCP与UDP通过多路复用与解复用实现多个协议实体同时使用服务
- [多路复用和解多路复用的原理在于端口号和ip地址的识别]，传输层封装的PDU包含目标端口的信息，与其对等的传输层拿到报文段后，会识别目标端口(IP同理)，因此可以识别出该报文段应该给哪个进程，也就是说，多路复用和解多路复用就是一个“龙门飞甲”的过程。
# 差错检测
> 差错检测指在数据传输过程中检测数据是否发生了错误
> `差错检测码（EDC）`是通过在原始数据中添加`校检值`来检测数据传输或存储过程中是否发生错误的编码技术
- 常见的差错检测有：`奇偶校验`，`循环冗余检验`，`校验和`
> 通过比较校检码可以判断数据是否出错
- 接收方获取数据后，根据算法重新计算校检码，[如果一致，则大概率没出错，如果不一致，则一定出错。]
# UDP
## UDP概念
> UDP是尽力而为的服务，报文段可能丢失也可能乱序
- UDP没有为网络层服务提供额外的功能。
> UDP常用于流媒体，DNS，DHCP等容忍丢失的情景
- UDP存在许多优点：
    1. 无连接，延迟小
    2. 数据量小（头部信息小）
    3. 能发挥最高的传输效率（无拥塞和流量控制）
- 因此尽管UDP存在丢失，乱序等特点，但其也获得了优点，这本质是个平衡.所谓能发挥最高的传输效率指的是[应用进程发送数据有多块，其传输就有多快]，因为其没有拥塞和流量控制。
## UDP报文
> UDP报文头部由`src port `和`des port`，`字节长度`，`校验和`共`八`个字节构成
 0                   1                   2                   3   
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Source Port          |       Destination Port        | → 四元组核心
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Length             |           Checksum            | → 总长度/校验和
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Data                              | → 应用层数据
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                            `UDP头部`
- [UDP使用校检和来提供一定程度的数据保障]，至少让你知道出错了，对于检验和的原理，我们只需要知道其[将数据分块（每块16bit）求和，结果取反作为校验值，如果接收方计算的结果为16位全一，那么就是正确的]。具体的计算算法不展开。
> UDP校验和错误的报文段会被丢弃
- 比较尴尬的是，正如其他EDC一样，[UDP校验和一致不一定没出错，但是不一致一定出错]

# 有限状态机
> 有限状态机是对象在它的生命周期内所经历的状态序列模型
- 理解rdt需要先理解有限状态机，有限状态机是IT领域很重要的一个概念，是计算思维的重要构成。有限状态机它描述了[一个系统在任何给定时刻只能处于有限数量的“状态”中的一个。系统通过响应外部输入（事件）从当前状态转换到另一个（或同一个）状态。]
>有限状态机（FSM）有四大核心要素：有限状态集合，有限外部输入集合，转换函数，初始状态
  - `有限状态集合`，就是[FSM可能处于的状态列表]。
  - `有限外部输入集合`，就是[FSM能识别响应的外部输入事件的集合]
  - `转换函数`是[输入事件的响应与状态列表的映射]
  - `初始状态`是[FSM在等待外部输入事件期间处于的状态]
> 有限状态机需要满足`离散性`，`有限性`，`唯一性`，`无记忆性`
- 离散性指出有限状态机的状态变化，事件输入一定是发生在离散的时间点，而不能是连续的。讲不严谨点，有限状态机一定是按步运行的。在之前的《计算机科学导论》中学到过音频采样的过程：将连续的声音信号转换成离散的二进制数值，相信离散性不难理解。
- 唯一性是由转换函数的本质决定的，转换函数是映射，因此必然要求唯一
- 无记忆性指出FSM不维护状态和事件输入历史，其下一状态仅取决于下一输入事件
*以红绿灯为例子*：
![alt text](D:\Github code\diefei\Markdown素材库\Markdown 素材\FSM.png)

# 可靠数据传输（rdt）
- 网络层自身与其以下提供的服务都是不可靠的，而TCP需要提供可靠的服务，因此`如何实现这个可靠数据传输rdt`，`需要解决什么问题`是本章需要解决的问题
> 底层channel的不可靠性，决定了rdt协议的复杂性
- 在rdt协议中，[如果底层channel是可靠的，也就是不出错（不存在比特反转）不丢失，那么传输层只需要充当一个数据传输的中介即可],随着特性的逐一丢失，传输层就需要做出额外的努力，来维持可靠性
## rdt 1.0
> rdt1.0是经过完全可靠信道传输时使用的协议
- 正如我们上面所说，[如果使用的信道是完全可靠的，那么传输层无需做出额外的努力]。
  - 发送方FSM的状态集：{`等待上层调用`}
  - 发送方FSM的事件集：{`rdt_send()`}
  - 发送方动作集：{`make_pkt,udt_sent()`}

  - 接收方FSM的状态集：{`等待来自下层的调用`}
  - 接收方FSM的事件集：{`rdt_rcv()`}
  - 接收方FSM的动作集：{`extrac(),deliver_data()`}
- 我们可以看出rdt1.0其实相当简单
- 原理图：
![alt text](D:\Github code\diefei\Markdown素材库\Markdown 素材\rdt1.0.png)
## rdt2.0
> rdt2.0是为规避比特差错检测而引进校验和机制的协议
- 现在我们移去信道的一个特性。当信道存在比特差错时，TCP需要做出额外的努力
> rdt2.0FSM的集合
  - 发送方FSM的状态集：{`等待来自上层的调用`，`等待ACK/NAK`}
  - 发送方FSM的事件集：{`rdt_send(data)`，`rdt_rcv(rcvpkt)＆isACK(rcvpkt)`，`rdt_rcv(rcvpkt) &isNAK(rcvpkt)` }
  - 发送方FSM动作集：{sndpkt = make_pkt(data, checksum)，udt_send(sndpkt)}

  - 接收方FSM的状态集：{`等待下层调用`}
  - 接收方FSM的事件集：{`rdt_rcv(rcvpkt) & not corrupt(rcvpkt)`,`rdt_rcv(rcvpkt)& corrupt(rcvpkt)`}
  - 接收方FSM的动作集：{`udt_send(NAKpkt)`，`data = extract(rcvpkt)`，`deliver_data(data)`，`udt_send(ACKpkt)`}
> rdt2.0的原理
- 由于加入了检测校验和的机制，因此[发送方的FSM在rdt_send（date）后会从等待来自上层的调用进入等待ACK/NAK的状态，接收方rcv后会重新计算收到分组的校验和，然后判断分组是否损坏]。
  - 如果损坏：[接收方发送NAK，发送方收到NAK后，send重传上一个数据，保持在等待ACK/NAK状态，这一过程会不断重复直到接收方收到完整的分组]
  - 如果未损坏：[接收方发送ACK，然后extract，然后deliver]
*原理图*：
![alt text](D:\Github code\diefei\Markdown素材库\Markdown 素材\rdt2.0.png)
> rdt2.0的致命缺陷
- 虽然rdt2.0的FSM看起来很复杂，但其实逻辑上很好理解。[rdt2.0的缺陷是：ACK/NAK本身也可能会损坏，如果ACK/NAK损坏，导致发送方无法判断究竟是ACK还是NAK，重传可能导致重复，不重传可能死锁]
## rdt2.1
> rdt2.1针对rdt2.0的缺陷进行了改进，加入了序号机制
- 我们遇到的问题是：如果ACK/NAK损坏，那么发送方就不知道该干嘛了，因此[rdt2.1在ACK/NAK损坏时，发送方直接重传]，那么如何解决重复问题呢？[rdt2.1在分组（ACK/NAK分组和数据分组）加上一个序号（0/1）]
> rdt2.1接收方根据序号判断发送方是否重传
- 接收方如果接收到与上次接收相同序号的分组，如果上次发送的是NAK，那么这是正常的，如果发送的是ACK，那么接收方就知道上一次的ACK出错了，这时其会丢弃该分组，并重新发一个ACK，接收方实际是在期待新的分组
> rdt2.1的FSM的集合
- [rdt2.1的发送方FSM一共有4个，而接收方一共有2个]。事实上，它们是基于rdt2.0的两个状态拓展而来的。这个[序号机制的本质是利用0和1的循环性进行标识]。rdt2.1在发送完标识为0的分组后，会开始发送1的分组，然后再发0的，发送0和1的机制完全相同，因此我们可以认为，[发送方FSM的4的状态是2个镜像的2个状态]。因此我们只需要关注fsm的状态集合，至于动作和事件，与rdt2.0是类似的
  - 发送方FSM的状态集：{`等待来自上层的调用 0`，`等待ACK/NAK 0`，`等待来自上层的调用 1`，`等待ACK/NAK 1`}
  - 接收方的FSM的状态集：{`等待下层调用 0`，`等待下层调用 1`}
*原理图*：
![alt text](D:\Github code\diefei\Markdown素材库\Markdown 素材\rdt2.1.png)
![alt text](D:\Github code\diefei\Markdown素材库\Markdown 素材\rdt2.1的过程.png)
## rdt2.2
> rdt2.2取消了NAK，用前一个分组的ACK代替对当前分组的NAK
- rdt2.1虽然解决了缺陷，但是其仍然是差强人意的，因为效率太慢了，ACK k其实有两层意思，ACK k 明确表示“分组 k 已被正确接收”，同时也隐含了“我（接收方）期望的下一个分组是 k+1，如果接收方又发送分组k的ack，就证明ACK k的传递出现了问题。
- 如果出现问题（发送方发送的packet确实有问题，需要重传；ack出了问题，发送方以为要重传）接收方会发送前一个ACK k，这样发送方就知道自己上一个出现问题，就知道要重新发，接收方接收到正确的后，再发一个ack k+1
---------------------------------------------------------------------------------------------
## rdt3.0
> rdt3.0引入超时重传机制
- [rdt2.1和2.2都是假设分组不丢失的]，可是我们知道分组的丢失是很常见的网络错误。那么我们假设[分组或ACK直接丢失了，那么发送方或者接收方无法区分分组究竟是在路上，还是没了，就会进入无下界的等待情况，也就是会死锁]。因此最简单的方法就是告诉发送方或者接收方，如果等待了一定的时间还没有信息，就重新发送。
> 发送方发送一个分组，会启动一个`超时定时器`，如果在定时器结束时，还没收到来自接收方的ACK，那么就会重新发送。如果收到了正确的ACK，那么就停止定时器，发送下一个,然后启动新的定时器
- 那么这个超时定时器究竟设置多长时间呢？一般链路层的超时定时器设置为一个固定的值，因为链路层是点到点的数据传输，而传输层是基于网络层端到端的数据传输，点到点的传输时延比较稳定，因此[点到点可以设置一个固定的值，而端到端的时延比较复杂，一般是动态地设置。]
- 另一个问题是，如果这个超时定时器的设置不合理，运气差的ACK还没到，就已经结束了，这意味着双方的数据传输会存在大量的重复。也就是说[rdt3.0的性能严重依赖于合理超时定时器的设置]
> rdt3.0忽略否定ACK，利用超时重传来实现重发
- 在rdt3.0中，接收方通过checksum判断分组0出错，其会发送ACK1，在rdt2.2中，这意味着分组0出错，发送方会重传分组0，但是在rdt3.0中，这个[ACK会被忽略，分组的重发靠超时重传机制来实现]
---------------------------------------------------------------------------------------------
## 停止等待协议与流水线协议
> 流水线协议允许连续发送而无需等待接收方的响应，停止等待协议则相反。
- 所谓停止等待，就是发送方一定会等到接收方的响应，再发送下一个数据，rdt是停止等待协议，而像是持续性http则是`流水线协议`
> stop and wait协议在带宽很大的链路存在大量的浪费
- 毫无疑问，一次只能发一个分组是很浪费的，在链路比较窄时不明显，但是一旦链路很宽，就难以接受了。
## 滑动窗口协议(slide window)
> 滑动窗口协议提供了发送缓冲区和接收缓冲区，发送方和接收方各自维护一个存储已经发送或接收的分组序列号的范围，称为“窗口”。
- [缓冲区是内存中的一个区域]缓冲区的[大小是有极限]的，其不能超过链路的带宽上限。随着协议的运行，窗口的起始位置和结束位置会向前`滑动`。
> 发送窗口存储发送但未被确认的分组
  - 我们用一个队列[S_f,S_n-1]来抽象发送窗口允许发送的缓冲区范围，其中S_f是第一个发送但未被确认分组，n是下一个要发送的分组，那么很显然，S_n-1-S_f ≤ W（窗口大小）；注意这个S_ f会随着窗口移动而变化，其代表队列的队尾的顺序
  - [队列中的分组出列的条件是该分组被确认]。
> 接收窗口存储接收但未发送确认的分组
  - 同理，我们用[Rf,Rf+W-1]来抽象接收窗口允许接收的缓冲区范围
- 发送窗口是一个队列，这样就意味着在实际的滑动窗口协议中，是分组被装进队列，而不是发送窗口在移动。但是我们出于好理解，还是认为窗口在动。
> 根据发送缓冲区和接收缓冲区大小的不同，我们可以将滑动窗口协议又分为：停止等待协议，回退N重传协议（GBN），和选择性重传协议（SR）
- 我们用s代表发送方的缓冲区大小，用r代表接收方
  - 当s = r =1 ，这实际上就是sw ；当s ＞1 ， r =1 ，这实际上就是gbn ； 当s和r都＞1，就是SR
  - 其中当s＞1时， 这些协议就是`流水线协议`，[流水线协议允许发送方在未经接收方确认的情况下，一次发送多个分组]
## GBN协议
> GBN的核心是累积确认和回退N步重传
- 如果我们希望将rdt3.0从停止等待协议升级为流水线协议，我们需要思考这几个问题：
  1. 分组出错怎么办？
  2. ACK出错怎么办？
  3. ACK丢失怎么办？
  4. ACK延迟怎么办？
  5. 分组丢失怎么办？
  6. 分组延迟怎么办
- 也就是说，我们需要考虑的就是`确认`和`重传`的这两个问题。
### GBN的工作过程
> 发送方的GBN的工作原则：
发送：
  `发送仅在且一定会在Sn < Sf + W（窗口内有可用位置）时响应上层，封装并发送新的分组`。
  `一次性发送w个分组，w为设置的发送窗口长度，然后等待，直到Sn < Sf + W。`
  `定时器始终只为当前Sf（最早未确认分组）存在，`
处理：设收到ACK的顺序为n，
  `如果n=ACKS_f：将S_f推出去，定时器指向新的S_f；`
  `如果收到n>S_f，n+1成为新的S_f，n之前的分组全都被推出去，定时器指向新的S_f；`
  `如果收到n< S_f ，忽略。如果S_f的定时器响了，则重传发送窗口全部的分组。`
> 接收方 GBN的工作原则
接收：
  设接收的分组序号为n（初始n=0），返回ACK n。接收方只接收n+1，丢弃其他全部到达的分组，并发送ACK n（n+1-1）
  如果分组n出错，发送ACK n-1 ，接收后续分组时，丢弃，发送ACK n-1 ，直到收到正确的ACKn
  `每当接收方接收到不合适的分组（出错或提前），其会发送ACK [期待n-1]`
  `接收方不必接收一个返回一个，可以接收多个后再返回最后接收的ACK`
原理：
  ![alt text](D:\Github code\diefei\Markdown素材库\Markdown 素材\GBN.png)
- 我们来回答之前的6个问题：
  1. `分组n丢失`，接收方发送分组序号n-1的ACK，这个ACK一定小于S_f（因为ACK n-1会令S_f=n）；
    例如对于发送窗口：[N，N+1，N+2，N+3]，如果N+1出错，那么发送ACK N，ACKN会令S_f = N+1
    那么ACK N会被忽略，后续接收方接收N+2，N+3都会丢弃并发送ACK N，直到ACK N+1的超时定时器时间耗尽
    重发N+1，N+2，N+3（其实还有N+4，因为N被推出，会立刻发N+4），至此，应该不难理解为什么接收方会丢弃不符合的到达分组。
  2. `分组N延迟`，由于接收方的接收特点，先到达的都会丢失，并发送ACK N-1，由于N-1 被推出，最后也是依赖
     定时器重新发送N以及后续所有已发送的分组 
  3. `分组N出错`，也是同理
  4. `ACK延迟`，接收方只在乎最大的ACK，这个不难理解，不赘叙
  5.` ACK丢失`：接收方只在乎最大ACK是否丢失，例如，N是S_f，N丢失，只要N+1，2，3任意一个到达即可，我们假设ACK N，N+1，2，3，全都有问题。比如ACK N丢失，分组N+1丢失，ACK 2 ，3 被丢弃。那么接收方会发送ACK N(N+1-1)，相当于补发了。
  6. `ACK出错`：与5一样，出错和丢失对于发送来说没啥区别。
- 退一万步来说，反正有定时器，接收方和发送方总能回到同一频率的
## SR协议
- GBN协议已经很天才了，可是其仍然有缺陷，那么就是，其发送了太多的重复分组，在w比较大的时候，一个出错就浪费资源重传许多没有必要重传的分组。
> SR的核心是独立确认+ 选择重传。
- SR的想法简单直接，堪称大道至简
### SR的工作过程
>  发送方的工作原则：
  - 其工作原则与GBN类似，有一个区别：
    1. `SR为每一个已发送分组设置一个定时器，如果收到来自接收方对该分组的确认，就关闭定时器，分组移出发送窗口。`
  - `SR的发送窗口只有在S_f的定时器关闭时才能向前移动到下一个分组，这与GBN是一致的`
> 接收方的工作原则：
 - `接收方可以缓存乱序到达的分组，每收到一个分组就返回一个对应的ACK。`
 - `接收方在上交数据时，会按序排列分组，如果缺少，其会等到发送方重传，而不会主动要求。`
 - `接收方如果收到重复的分组，其会丢弃，但也会返回ACK`
- 之前的那六个问题都采用一个解决方式：分组只要没被确认，我就重新发，发到你确认为止。
### SR的最大序号
> SR 协议要求 发送窗口大小 W_t + 接收窗口大小 W_r <= 序列号空间大小（2^k）
- 这主要是为了避免旧分组和新分组序号混淆（超出序号会溢出，导致序列号空间回绕问题）
- 值得关注的一种情况是，w_r小于w_t，这会导致w_t发送的份分组被忽略（不缓存，不ACK，不NAK）因此w_r一般来说，都与w_s大小一致。也就是：W_t = W_r = W，所以要求 W <= 2^(k-1)（例如，k=3 位序列号，W<=4）。
### 对比GBN和SR
> GBN的优点是实现简单，但是出错代价大，因此适用于分组出错概率低的情况
> SR的优点是链路带宽利用率高，出错代价小，缺点是实现复杂，且延迟会增加，因此适用于链路容量大时

# TCP
## TCP的特点
> TCP是点对点，面向连接，面向字节流，全双工，流水线，存在拥塞控制和流量控制的可靠连接
- 之前我们已经讨论过TCP的一些特点，现在我们对其中一些特点进行补充
  - 所谓面向连接，指的是使用[TCP进行数据传输的两个协议实体在传输数据前，需要先握手，传递报文段以确定连接参数。]
  - 所谓全双工，指的是[一个TCP连接包含两个独立的、方向相反的数据流]
  - 我们之前提到过TCP是不维护应用层的消息边界的，数据是以字节为单位连续传输的。具体来说，TCP会将上层提供的数据按MSS的大小，分割成若干等长的报文段，TCP只关心每个报文段的大小是否等于MSS，而不在乎它们的语义边界
> TCP的MSS取决于MTU于通信双方的协商
- [来自应用层的数据需要经过网络层和传输层的封装，被封装进帧]。以太网帧的理论有效载荷为1500，传输层和网络的封装需要占用40个字节（通常），因此1460是MSS的一个典型值，但不是绝对的，因为MTU还收到瓶颈MTU的影响。
## TCP的可靠数据传递
> TCP是以GBN框架为基础，通过接收方缓存 + 快速重传 + SACK 引入了SR的高效重传能力的混合协议
- 我们之前提及过GBN和SR，它们是通用的可靠流水线传输协议，TCP建立在其基础上，但不完全相同。
- 首先TCP的接收方的r>1，这与SR是类似的。
- GBN面对不合适的分组会直接丢弃，因此发送方发送的不合适的分组实际上接收方一个都没收到，因此我们需要通过发送ACKn-1，让sendbase指针指向不合适的分组，触发超时重传机制
- TCP的思路类似，但是其发送期待ACK（GBN发送已接收ACK），因此接收方发送的是n+1.又因为TCP的r ＞1，因此不合适的分组其实也到达了，因此接收方返回新的期待ACK即可，表示累积确认
- 因此我们不难发现[ACK的本质，在各个技术中，ACKnumber实际上指示basement指针的行为，让basement指向接收方期待ACK]
- TCP本质是取消掉了SR需要发送方为每一个发送分组维护定时器的麻烦，只维护一个指向basement的定时器，用GBN的累积确认，快速重传和选择重传(SACK)提高重传效率；TCP采取了SR 的接收方缓冲区r>1的设计，避免了GBN需要完整重传发送窗口全部分组的麻烦，因为乱序到达的分组不会被丢弃，而是被缓存，发送方只需要重传定时器指向的，最老的未确认分组。
## TCP可靠性的技术实现
> TCP的序列号确认机制
- [发送方为每个字节分配唯一序列号，报文段只携带起始序列号]。
- [接收方对到达的数据进行累积确认，其始终发送连续收到的数据的最高字节序号+1（ACK总是为期待字节的序号）]
> TCP的滑动窗口协议
- 发送窗口维护三个指针，
  1. SendBase：最早未确认字节序号（窗口左边界）
   - [如果n＞sendbase，sendbase指向n]
   - [如果n小于sendbase，忽略]
   - [如果n=sendbase超过四次，重传]
  2. NextSeqNum：下一个待发送字节序号
  3. 窗口大小 = Min(接收方通告窗口, 拥塞窗口)
- 接收方乱序缓存到达的分组，按序交付数据给上层
  - [期待ACK始终为连续收到的数据的最高字节序号+1],我们从两种情况来看：假设分组[900,999]丢失，后续[1000-1099]，[1100-1199]到达，此时连续收到的数据的最高字节为999，而不是1099和1199，因为此时899-1000之间是不是连续的。后续等900-999到达，此时连续的最高字节变成了1199，因此接收方返回ACK1200
> TCP的超时重传机制
- [只维护basement一个超时定时器]
- [快速重传：如果连续收到三个重复ACK，则立刻重传该数据，而不是等待定时器]
- [选择重传：接收方在发送ACK时，通过SACK选项显式告知乱序到达的数据块]
> 校验和：
- [接收方重新计算checksum，如果不对则丢弃]
>  延迟确认机制
- [TCP接收方允许连续接收到多个按序到来的分组后，一次性发送最后的ACK]。当然如果出现乱序到达，或是第二个超过了一定时间（通常是500ms）则需要立刻发出之前一个分组的ACK
  *同样的，我们来思考这几个问题*：
1. Q：如果不丢包不出错，TCP如何运行？
   A：发送方发送seq = 0的0-999的分组，接收方返回ACK=1000，发送方再发送seq = 1000的1000-1999的分组，接收方返回ACK=2000......这样的传输是美好的
2. Q：如果分组丢包了，TCP如何运行？
   A：发送方发送seq = 0的[0-999]的分组，接收方返回ACK=1000，发送方再发送seq = 1000的[1000-1999]的分组，此时这个分组丢包了，发送方继续发送seq = 2000的[2000-2999]、3000、4000的分组，直到发送缓冲区满。此时接收方没收到seq=1000的分组，其发送ACK = 1000 告诉发送方，我期望初始序号为1000的分组，后续每收到一个分组，接收方都是发送ACK =1000，发送方接收到了连续3个重复ACK =1000，发送方马上重传。当接收方终于接收到了seq1000，由于它已经接收到了seq=4000，因此其返回ACK 5000（始终发送连续收到的数据的最高字节序号+1）。此时发送方接收到ACK 5000，则sendBase = 5000，将之前的分组全部视为已被接受。
## TCP 三次握手
### 捎带
> TCP的捎带使得A对B的ACK回应可以捎带在A对B的Data中
- TCP是全双工的连接，这就意味着[发送方同时也是接收方，它不仅要发送报文段，也要确认对方的报文段]
### 三次握手必要性
> TCP三次握手期间，协商通信所需要设置的标志位，检验通信意愿和能力
- 为什么要握3次手？
  1. 第一次检测发送方的通信能力，第二次检测发送方的通信和接收能力，第三次检测发送方的接收能力。因此需要3次。如果两次握手，客户端请求的连接可能来自超时重新连接，因此需要客户端再次确认，证明自己是活跃的
  2. 标志位发送方和接收方分别要对方提供seq =X，seq =Y，同时需要发送ACK num =Y+1和ACK num = X+1；这理论上来说需要四次，但是[seqY和ACKX可以捎带成一次]，所以最少需要3次
### seq交换的必要性
> 每一次TCP连接的初始seq都是随机的，需要双方协商交换，而不是采用固定的seq值。这是出于安全和稳定的考虑
  1. 若[新连接使用相同ISN，延迟到达的旧连接报文可能因序列号匹配被错误接收可能导致数据混乱或注入攻击]。
### TCP三次握手过程
> 第一次握手：A方设置SYN=1,Seq=x
> 第二次握手：B方设置SYN=1，Seq=y，ACK=1，ACKnum=x+1
> 第三次握手：A方设置ACK=1，ACKnum=y+1
*FSM*：
![alt text](D:\Github code\diefei\Markdown素材库\Markdown 素材\三次握手.png)
## TCP的四次挥手
- 我们刚刚介绍了三次握手建立连接的过程，那么TCP如何关闭连接呢？TCP通过四次挥手关闭TCP连接。为什么是四次呢？因为TCP是全双工协议，数据是双向的，单向的关闭需要发送关闭请求和同意请求，因此自然是4次
> 第一次挥手：A方设置FIN=1，Seq=x
> 第二次挥手：B方设置ACK=1，ACKnum=x+1
> 第三次挥手：B方设置FIN=1，Seq=y
> 第四次挥手：A方设置ACK=1，ACKnum=y+1
## TCP 的流量控制
> 流量控制是防止发送方发送数据过快导致接收方缓冲区溢出的机制
> 接收方通过报文段里的Windows size value 告诉发送方自己缓冲区的大小，发送方根据大小调节发送速率
## TCP 的拥塞控制
> 拥塞控制是防止端到端之间的网络堵塞而导致丢失和时延问题
- 拥塞会带来许多糟糕的结果，首先是由于拥塞，丢包率会明显增加，进而时延增加。由于超时重传机制，发送方需要发送更多的重复的数据包，这会使本身就拥塞的网络进一步恶化，甚至死锁，那就很坏了
> 端到端的，网络辅助的拥塞控制是常用的两种拥塞控制
- [网络辅助的拥塞控制就是网络核心显式返回拥塞信息，端系统进而提高/降低发送速率]
- [端到端的拥塞控制则相反，需要端系统通过事件来判断是否拥塞]
> TCP 采用端到端的拥塞控制方案
## TCP报文：
   0                   1                   2                   3   
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Source Port          |       Destination Port        | → 四元组核心
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Sequence Number                        | → 数据字节流的起始序号
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Acknowledgment Number                      | → 期望收到的下一个字节序号（ACK）
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Data |           |U|A|P|R|S|F|                               |
| Offset| Reserved  |R|C|S|S|Y|I|            Window             | → 窗口大小（流量控制）
|       |           |G|K|H|T|N|N|                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Checksum            |         Urgent Pointer        | → 校验和/紧急指针
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options (if Data Offset > 5)               | → 可选字段
|                             ...                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Data                              | → 应用层数据
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                           `TCP头部`
## 头部关键字段
> Sequence序号是公差为MSS的等差数列
- 我们之前提及过，TCP是面向字节流的，因此每个MSS的序号是其在字节流中的序号
> Acknowledgment 
- ack是确认号，其告诉通信对方自己期望收到的下一分组序号，其理论上等于Seq+1
> checksum
- checksum与UDP一样，不赘叙
> ACK,SYN,FIN标志位
- ACK 置1，使得ACKnumber有效
- SYN 置1，代表请求连接
- FIN 置1，代表请求关闭连接
