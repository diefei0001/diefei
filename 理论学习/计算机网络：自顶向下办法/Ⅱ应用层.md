# 应用层原理
## 网络应用的体系结构
> 常见的体系结构有C/S，P2P，混合模式
- 在C/S模式中，服务器拥有`固定的IP和周知的端口`，一直保持运行，`等待`客户端（client）向其发送请求。
- P2P中的每个节点[既向别的节点请求资源，又根据自身拥有的资源，向别的节点提供资源。],新peer带来新的服务请求，也带来新的服务能力。
- 即时通讯是混合模式的一个例子，上线向服务器报告属于集中式（C/S），两个用户通信则是P2P模式
> 应用层的进程进行通信依靠传输报文（message）进行通信
> 通信进程可以分为客户端和服务端
- 发起通信请求的进程称为客户端，响应通信请求的进程称为服务端
- 在P2P模式中，peer既是客户端又是服务器，但是在会话上，也有客户端和服务器之分
## 网络层的进程
> 网络应用是网络存在的理由

### 网络进程通信
> 网络进程通信需要解决一系列问题
- `进程标识`与`寻址`问题
- 传输层提供服务的`SAP`和`原语`问题
- 服务用户`如何使用服务`问题
- 信件传递是一个很好的类比，通信双方需要知道对方的名字（`唯一标识`）和`地址`。[进程标识和寻址问题]需要知道信件应该投入哪个信筒（`SAP`），需要明确是以邮件投递的方式（`原语`）进行传递信息[SAP和原语问题]在信封上，需要写邮编，写地址.信的内容也有具体的格式[如何使用服务]
> 进程通过`ip地址`和`端口号`标识自己和地址
> 传输层通过层间界面的socket（sap）和应用进程接口（原语）向应用层提供服务
> 应用进程如何使用服务
- 应用进程穿过层间接口，需要携带`SDU`+`自己的IP+TCP（UDP）端口`+`对方的IP+TCP（UDP）端口`，拥有这些信息，传输层才能进行封装。
- [应用进程通过socket套接字与对方应用进程进行通信]，socket就像是游戏《protal》里蓝黄传送门一样，报文从蓝色传送门进入，会从黄色传送门出来。
- 应用进程还需要[定义应用层协议：报文格式，解释，时序等，编制应用程序]
.
-------------------------------------------------------------------------------------------------
## 传输层提供服务的指标
> 传输层提供服务的指标包括：`数据丢失率`，`延迟`，`吞吐`，`安全性`
- 丢失率关联[可靠性]，指的是数据是否会丢失，丢失后是否重传
- 延迟顾名思义，就是[传输信息所需的时间]
- 吞吐是数据的有效传递的量
- 安全性强调数据的私密性
> 不同的网络应用对传输层提供服务的指标的关注/在意程度不同
- 有的[文件类应用，例如电子邮件，对丢失率敏感]；有的[多媒体应用，例如语音与视频，对延迟较为敏感]，称为`时延敏感应用`；[多媒体应用还要求最低吞吐量，以保证应用正常运行]
- 因此应用根据自己的需求选择TCP和UDP,如果对安全敏感，可以采用SSL，SSL能加强TCP的安全性，类似于HTTPS相较于http。
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
> TCP套接字维护一个4元组的一个具有本地意义的标识，代表进程通信的会话关系
- 进程进行TCP通信期间，socket会维护一个包含`源宿ip，源宿端口`的数据表，内核协议栈在发送数据时，[从Socket提取四元组信息]，填入对应协议头字段。
> UDP套接字维护一个2元组的标识，代表源IP，源端口，代表进程通信的会话关系
- 因为UDP是无连接的，因此[UDP套接字默认不包含目标端口目标IP]，因此使用UDP进行通信[需要提供SDU，UDP套接字，目标IP和目标端口]，但是连接后，后续的报文段传输则不需要提供目标ip和端口了。前者称为未连接状态，后者称为已连接状态
- 示意图：
  ![alt text](diefei\Markdown素材库\Markdown 素材\TCP socket.png)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Web和Http
## Web
> Web页是由包含若干对象的URL的基本Html文件
> URL格式
                      `协议名——域名/ip——路径名——端口`
- 我们在输入URL时，不少都是默认的，例如端口
> Web是最典型的C/S模式，浏览器是客户，Web服务器是服务端
- 浏览器最重要的部分是渲染引擎，也就是内核，负责将Web服务器发送的对象进行渲染成一个完整的网页
## Http
> 超文本传输协议是Web的应用层协议
- 不同的浏览器可以访问同一个Web服务器，这是因为它们都遵守Http协议
> Http协议建立在TCP之上，端口是80
## Http的工作过程
- 步骤：
  1. 建立连接，TCP三次握手
  2. 发送Http请求报文
  3. 服务器处理请求
  4. 服务器返回Http响应报文
  5. 关闭/保持TCP连接
- `http示意图（非持久性）`：
  ![alt text](diefei\Markdown素材库\Markdown 素材\非持久性Http.png)
  ![alt text](diefei\Markdown素材库\Markdown 素材\非持久性Http（2）.png)
## 响应时间模型
> 往返时间rtt（round-trip time）是分组从客户端到服务器，再回到服务器的时间，其中建立TCP需要一个Rtt，http的发送和响应需要一个Rtt，因此，传输一个文件需要2Rtt+传输时间
- 示意图：
- ![alt text](diefei\Markdown素材库\Markdown 素材\Rtt.png)
## 持久性Http与非持久性Http
> Http 可以分为持久Http和非持久http，Http1.0使用非持久http，Http1.1使用持久http
- 所谓非[持久http，也就是一次tcp建立传输一个对象]，下载多个对象需要建立多次TCP。而[持久Http则可以实现多个对象在一个TCP上传输]，二者的[区别就在于第五步是关闭还是保持TCP连接]
- [非持久性http传输一个文件至少需要2个Rtt]，同时重新建立TCP需要消耗资源
- 持久性http[省去了后续建立TCP连接的繁琐步骤，并且可以使用流水线技术]。非流水线Http顺序执行多个对象的请求和响应任务，[客户端只能在收到前一个响应后才能发出新的请求]。流水线Http[遇到一个对象请求就立马发送，而无需等待上一个请求被响应]
## Http报文
> Http请求报文可以分为`请求`和`响应`两种
> Http报文是ASCII格式的英文进行书写
> Http请求报文的通用格式：
- 总体来说，可以分为`请求行`，`首部行`，`请求体`。
`示意图`：
![alt text](diefei\Markdown素材库\Markdown 素材\Http请求报文通用格式.png)
> http请求报文详解：
- 我们以Get方法为例子：
*报文*
GET /get HTTP/1.1 
Host: httpbin.org 
Connection: keep-alive 
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36 Edg/136.0.0.0 
accept: application/json 
Referer: http://httpbin.org/ 
Accept-Encoding: gzip, deflate 
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6 
*报文*
- 在这个报文中，请求行的`方法为GET`，`URL为/get` `版本为HTTP/1.1`，[首部行中包含7个首部行字段]，`Host字段是http1.1强制要求`的，`Conection指明了连接方式`：`keep-alive，这说明其为持续性http`，这也是http1.1的默认连接方式，`User-agent是用户使用的浏览器`，事实上，某些服务器没有对某浏览器进行支持，为了避免这个问题，Http报文往往会堆叠浏览器标识，欺骗服务器。
`Accept-Language`告知服务器应该返回的语言
> http 请求报文方法
方法	  安全	幂等	请求体	典型场景
GET	    ✅	  ✅	  ❌	    获取资源
POST	  ❌	  ❌	  ✅	    创建资源或提交数据
PUT	    ❌	  ✅	  ✅	    全量更新资源
DELETE	❌	  ✅	  ❌	    删除资源
PATCH	  ❌	  ❌	  ✅	    部分更新资源
> Http响应报文的通用格式：
- 总体来说，可以分为`状态行`，`首部行`，`数据`
`示意图`：
![alt text](diefei\Markdown素材库\Markdown 素材\Http响应报文通用格式.png)
> http响应报文详解：
我们以Post的响应报文为例子：
*报文*
HTTP/1.1 200 OK 
Date: Mon, 19 May 2025 19:52:00 GMT 
Content-Type: application/json 
Content-Length: 87 
Connection: keep-alive 
Server: gunicorn/19.9.0 
freeform:  
Access-Control-Allow-Origin: http://httpbin.org 
Access-Control-Allow-Credentials: true 
*报文*
- 在这个报文中，`状态行的http版本`为1.1 `状态码为200` OK，首部行字段有5个。`Date是发送该报文的时间`；`Server`类似于User-agent，`指示服务器的类型`；`Content-Type指示实体体的文件类型`；`Content-Length指示实体体长度`，这个响应报文的实体体为87个字节的json文件
> 状态码
状态码	名称	                       场景
200	    OK	                   请求成功。服务器返回请求的资源（如网页、API数据）。
201	    Created	               资源创建成功。常用于 POST 请求后返回新创建的资源路径。
204	    No Content	           操作成功但无返回内容。常见于 DELETE 请求或无需返回数据的更新操作。
400	    Bad Request	           请求错误。参数格式错误、缺失必填字段或数据不合法。
404	    Not Found	             资源不存在。URL 错误或资源已被删除。
500	    Internal Server Error	 服务器内部错误。代码异常、数据库崩溃等未处理的错误。
502	    Bad Gateway	           网关错误。反向代理无法从上游服务器获取有效响应（如后端服务宕机）。
503	Service Unavailable	       服务不可用。服务器过载或维护（如秒杀活动时流量激增）。
## 无状态与cookies
> Http是无状态的连接，其不记忆来自客户的上次请求
- 无状态指的是[客户端与服务器的每次通信都是独立的，服务器不会保存客户端的上下文信息]（如登录状态、操作步骤等）。这样的[优点是减少服务器的计算资源的开销，并且提高服务器的并发能力]，[缺点自然是无法支持需要连续交互的场景]
> cookies解决http无状态的无法维护客户端状态的问题.，cookies存在三个位置：`响应报文`，`请求报文`，`端系统`，`后端数据库`
- 当一个端系统请求一个从未请求过（或是手动清除cookie）的web服务器时：
   [web服务器会在响应报文添加cookie首部行] → [保留该客户的cookie在后端数据库] → [客户收到cookie后，将其存在端系统中] → [客户再次访问web服务器，请求报文带上cookie的首部行]
- 示意图：
![alt text](diefei\Markdown素材库\Markdown 素材\Cookies.png)
> cookies的缺点是可能涉及信息泄露与个人隐私问题等
## Web缓存（代理服务器）
> Web服务器可以设置Web缓存，允许客户不直接访问原始服务器从而获得数据
- 当客户向Web服务器请求时，如果Web缓存有，则直接返回，没有则向原始服务器请求。 类似于CPU里的cache memory，其存放着CPU常用的内存数据的副本。[client向Web缓存请求，如果成功返回，那么被称为`命中`]
> Web缓存降低了Web服务器的负载，降低了网络的消耗
- 互联网访问具有趋同性，因此在很小的缓存中，都能有很高的命中率
> Web缓存通过条件Get查询数据是否更新
- 另一个问题是，如何保证Web缓存数据的时效性？方法是，*当客户请求数据时，Web缓存向Web服务器发送condition Get，即发送if modified since <date>。如果没更新就返回信息：304 not modified ，更新了就返回新文件*
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Ftp
> Ftp也是典型的C/S模式，实现从远处主机下载文件或上载文件到远程文件
## Ftp基本原理
> Ftp使用TCP连接，使用双连接机制
双连接模式：`控制连接`和`数据连接`
`控制连接`默认[使用TCP21端口]。用于[传输FTP命令和响应]（如登录、切换目录、发起传输请求等）。在[整个会话期间保持打开状态]，直到用户断开连接。
`数据连接：`默认*使用TCP 20端口（主动模式下），或由服务器动态分配（被动模式下）*。功能：用于实际传输文件内容或目录列表。每次文件传输或目录操作时建立，完成后立即关闭。
> Ftp的两种状态：主动模式和被动模式

> Ftp工作过程
1. [建立控制连接]
客户端通过TCP连接到服务器的21端口，建立控制通道。服务器响应状态码（如220表示服务就绪）。
2. [用户认证]
客户端发送用户名（USER命令）和密码（PASS命令）。服务器验证后返回状态码（如230表示登录成功）。
3. `主动模式（Active Mode）：`
  客户端通过控制连接发送PORT命令，告知服务器自己的IP和临时端口。服务器从20端口主动连接到客户端的指定端口，建立数据连接。
4.` 被动模式（Passive Mode）：`
  客户端发送PASV命令,服务器返回一个动态分配的IP和端口（如227 Entering Passive Mode (192,168,1,1,202,143)）。
5. 数据传输完成后，数据连接关闭。客户端发送QUIT命令，控制连接关闭.
 > Ftp以ASCII形式传递数据，返回状态码和状态信息
200 OK：命令执行成功。
227 Entering Passive Mode：服务器进入被动模式。
230 Login successful：用户登录成功。
550 Permission denied：服务器拒绝操作（权限问题）。
553 Could not create file：文件名或路径无效。
425（无法建立数据连接）421（服务器端口被拦截）
## Ftp命令
> Ftp不同版本支持不同的命令，可以通过help查看
1. open <主机地址> [端口]建立Ftp连接
2. pwd dir cd mkdir rmdir ，命令与linux相同，作用于服务器文件系统
3. lcd 切换本地文件系统
4. get put delete 下载和上载文件到服务器
5. quit退出 
6. PASV 被动模式  
---------------------------------------------------------------------------------
# Email/SMTP/POP3/IMAP
## Email服务的构成
> Email服务由用户代理，邮件服务器构成
- [用户代理是Email服务的客户端]，常见的用户代理有：Google mail，outlook，qq mail等。所谓用户代理，也就是user agent，可以理解成为我们实现功能的软件。例如Http服务中，浏览器是我们的代理，帮我们渲染网页。同理，常用的邮件软件为我们实现了邮件的编辑，分发，删除等。
> 邮件服务器管理和维护发送给用户的邮件，分为发件方服务器和收件方服务器
- *值得注意的是*，[邮件必然经过发件方服务器和收件方服务器]，在跨平台邮件传输中，例如使用outlook软件发送邮件给谷歌用户，邮件会先以队列的形式被outlook服务器接收，然后outlook服务器将邮件转发给谷歌服务器。即使双方都是同平台，例如使用outlook发outlook，也需要将邮件发送到发件方服务器和收件方服务器。
- *另一个值得注意的是*，[收件服务器和发件服务器往往可以互相转换]，例如，收件服务器既可以收邮件，也可以发送邮件。但是在逻辑上，我们认为发送邮件需要通过发件方和收件方的服务器，至于这个功能是谁提供的，那不重要
> 发送邮件到email发件方服务器使用SMTP协议，代理从收件方服务器拉取邮件使用POP3/IMAP/Http
## SMTP协议
> SMTP建立在TCP上，服务器守候在25号端口
- 值得注意的是，SMTP包含了`代理向发件方邮箱发送数据`和`发件方邮箱与收件方邮箱互相通信`两种情况,前者代理为客户端，后者发送请求的一方为客户端。
> SMTP报文要求其报文所有内容都以ASCII书写
- SMTP起始于上世纪八十年代，因此其保留了一点缺点来告诉我们，他是一个古老的（对于IT发展速度来说）协议。其报文的全部，包括发送的邮件内容，只能用ASCII书写，也就是说，只能发送英文邮件，且无法发送图片，文件，可执行程序等附件。
> SMTP工作过程
- 代理A——<SMTP>——代理A的发件服务器———<SMTP>———代理B的收件服务器————<拉取>——代理B
- 上述是从一个整体来看邮件收发的操作，下面我们深入研究SMTP
1. 建立连接
   客户SMTP在25号端口建立一个与服务器SMTP的TCP连接
2. 交流
   `HELO`——`auth——`，交换确认对方身份与连通性
3. 发送邮件
   `Mail from` 和`rcpt to`命令明确发件方和收件方；`DATA命令`编辑邮件内容，邮件包含from和to以及Subject关键词，以`.`结束
4. 结束
   QUIT命令结束对话，关闭连接
> SMTP邮件
- 邮件首部行包括`To`，`From`，`Subject`，`CC`,`MIME版本`
- 主体则包含邮件内容和附件
> SMTP通过MIME（多媒体邮件拓展）标准，实现对ASCII以外的字符，附件支持 
- Base64 是一种将非英文字符，图片，可执行程序等转换为可打印 ASCII 字符的编码方式，因为计算机存储的数据本质都是二进制位模式，Base64的功能就是将二进制位模式映射到ASCII的字符范围内。
- MIME通过：
- Content-Type 头标识数据类型（如 text/html, image/jpeg）。
- Content-Transfer-Encoding 头指明编码方式
## POP/IMAP/Http
> POP3（邮局访问协议）和IMAP（Internet邮件访问协议），Http（超文本传输协议）是代理常用的拉取协议
> POP3工作过程：
1. [建立连接]
   客户端通过`TCP连接`到邮件服务器的POP3的`110号`端口
2. [身份验证]
   客户端发送用户名（USER）和密码（PASS）进行登录。
3. [发送命令]
   `LIST` 命令获取邮件列表及大小；`RETR `<邮件编号> 下载指定邮件。；`DELE `<邮件编号> 标记删除（实际删除在断开连接后生效）。
4. [关闭，删除被标记为删除的报文]
- POP3是一个极为简单的协议，POP3只能以`下载并删除`或`下载并保留`的方式从服务器下载邮件，[不能实现对在服务器对邮件进行管理]
> IMAP是实时访问和管理电子邮件的协议
- IMAP的邮件[始终保存在服务器]，并且[支持用命令直接在服务器上管理和访问邮件]，并且[支持多端同步]，也就是说，IMAP适合跨设备查看邮件
## 基于Web的邮件
- 现在基于Web的邮件是很常用的，在这个模式中，[浏览器成了代理]，[发送邮件到发件方服务器和从收件方服务器拉取都是用Http协议，但是服务器与服务器之间仍然使用SMTP]
# DNS
## DNS的三大功能：
> DNS实现域名与IP地址的转换
- ip地址用于标识和寻址，但是作为4字节的二进制数字，其难以记忆且没有辨识度。[域名是有语言意义的字符串，而DNS则是实现域名与ip地址的互换]
> DNS实现服务器别名向规范名称的转换
- [规范名称是指向服务器ip地址的真正名字，而别名是指向规范名称的名字]。例如linux中，我们可以通过alias命名为命令起别名，当我们输入这个别名时，其实际上会通过环境变量文件查询别名究竟指向哪个命令，然后读取该命令的路径并执行。服务器的别名也是一样的道理，例如我们输入www.163.com和直接输入163.com是一样的，因为www.163.com是163.com的别名。
- [当我们访问一个服务器的别名，DNS会指向其对应的规范名称]
> DNS实现负载均衡的功能
- DNS决定了请求的目标地址，那么[DNS可以根据地理因素，负载情况等一系列因素，选择最合适的服务器的ip地址返回]
## 域名
> 域名由多个层面进行层次化命名，每个层级用.分隔，最终形成一个树状的命名空间
- 顶级域有`全球通用顶级域`，也有`国家顶级域`。例如`.com`和`.edu`是通用顶级域，而`.cn`则是国家顶级域
- 二级域通常是`自行注册的域名部分`，例如各大高校的缩写，企业的名称等等。值得注意的是二级域名是[需要注册购买的，全球唯一。]
- 三级域是[用户自主创建的层级]，可以无限往下叠
- 以我们学校的cc网盘为例子：
                           `cc.szpu.edu.cn`
- 这是一个比较特殊的例子，在这个例子中，edu成了二级域，szpu成了三级域，因此[域名层级取决于域名在DNS树中的位置，而非点数]。在这个例子中，edu明显归中国政府所有，许多高校挂在edu的域名下面。
## DNS服务器
> DNS通过分布式数据库实现其服务
  1. 根域名服务器：最高级别的服务器，负责[返回顶级域的权威域名服务器地址]。
  2. 顶级域（TLD）服务器：[返回权威域名服务器地址]
  3. 权威 DNS 服务器：注册域名的[企业或个人自己搭建的服务器，管理和提供与其域名相关的域名解析记录和信息]
  4. 本地DNS服务器：代替客户端进行域名解析的服务器
> DNS维护资源记录以实现多种功能
- 资源记录是存储`name`，`TTL`，`value`,`TYPE`的数据表，其中[name是域名，TTL是保存时间，value是对应的ip地址，TYPE是类别]
> RR里的TYPE决定了其服务数据类别
- DNS有多个功能，例如实现域名和ip地址的转换，别名向规范名字的转换等，这些数据都存储在同一数据库里，通过TYPE进行区分
   1. A类型的value是IP地址
   2. AAAA类型的value是ipv6地址
   3. NS类型的value是权威服务器的域名
   4. CNAME类型的value是规范名称
   5. MX类型的value是邮件服务器域名 
## DNS的工作原理
> DNS服务通过递归查询的方式返回域名对应的ip地址
- `设备 → 本地DNS 服务器 → 根服务器 → .com 顶级域服务器 → xxxx 权威服务器 → 返回结果`
![alt text](diefei\Markdown素材库\Markdown 素材\递归查询DNS.png)
> DNS服务通过迭代查询的方式返回域名对应的ip地址
- 迭代查询中，[被询问的服务器只提供线索给本地DNS服务器，本地DNS服务器需要自己再次询问下层服务器]。
![alt text](diefei\Markdown素材库\Markdown 素材\迭代查询DNS.png)
- 二者的核心区别在于：`谁承担解析的责任`，`响应的内容是什么`.事实上，它们的区别是顾名思义的，一个是迭代的，一个是递归的
> 本地DNS服务器保存查询过的域名
- 设备向本地递归DNS服务器询问时，会[查找本地的DNS缓存记录，如果命中则直接返回，否则向根服务器询问]
> DNS服务器之间的数据传输跑在53号端口UDP
## DNS的安全性
> 攻击DNS的主要方式有DDos攻击，DNS劫持，DNS中毒等
## DNS报文
> DNS报文包含ID和flags以及若干字段
- [ID是当前查询任务的编号]，通过给任务编号，就可以实现流水线查询，而无需等待上次查询结果返回.flag是定义[查询/响应的类型、状态及行为]的2字节十六进制数
# DHCP
## DHCP的基本概念
> DHCP是实现网络设备自动化集中化管理的应用层协议
- 在一个大的网络集群中，手动为每一台计算机配置ip地址，DNS掩码，网关，子网掩码等数据是十分麻烦且容易出错的。DHCP不仅可以`避免手动设置的繁琐`，还能`简化管理`，`优化ip地址`的使用，尤其是在ipv4地址不够的情况下
## DHCP的功能
> DHCP可以实现ip地址的分配，配置参数的分发
- 我们都知道，一台计算机想要上网，需要ip地址，DNS，网关，子网这四个参数，DHCP可以实现这些常用参数的分发。
> DHCP是运行在UDP68和67号端口的C/S模型
- 客户端的端口是68，服务器的端口是67
## DHCP的工作过程
> DHCP客户端的工作过程可以分为Discover，Offer，Request，Acknowledgement，Nagtive Acknowledgment五个步骤，简称DORA。
### Discover过程
> Discover是客户端首次连接网络或需要更新配置时，发送的消息
- 当客户端首次连接到网络或需要更新配置时（如`开机`、`从睡眠唤醒`、`网卡启用`、`租约到期`），它会在本地网络`广播`一个DHCPDiscover消息。为什么是广播？因为客户端连DHCP服务器在哪都不知道！
> 广播第一步 [将0.0.0.0作为自身ip地址]，向 [广播地址（255.255.255.255）]发送Discover消息，Discover会被其他设备忽略或是被交换机泛洪，或是到达DHCP服务器
- 也就是说，没有网络配置的主机会向所有与它直接连接（注意是直接连接）的交换机发送请求消息，交换机会将消息`泛洪`，不同设备对这个消息的反应是不同的：
  - `普通终端设备`：不监听`67号端口`，所以被忽略了
  - `其他交换机`：继续泛洪，直到TTL耗尽
  - `DHCP服务器`：监听`67号端口`，会处理`Discover`
> Discover消息包含XID，标识客户端字段与请求的参数列表
- `XID`自然是为了流水线服务，DHCP要处理很多的请求，其依据ID进行返回，避免混淆,请求的参数也就是ip，dns那些了。
- `标识客户端字段`一般采用MAC地址，其核心作用是让DHCP服务器知道是谁在请求
### Offer过程
> Offer过程是DHCP服务器对客户端请求的应答过程
-当 DHCP 服务器[成功接收并解析一个DHCPDiscover消息]，并且确定自己`能够且应该为`该客户端提供服务时,其会返回响应信息
> DHCP服务器首先会严选ip
- 所谓严选，主要经历三步：
  1. [检查是否有基于该请求客户端的ip地址保留]，这个自然是通过标识客户端字段来查找的。如果有则返回保留ip地址。
  2. 如果没有，则[从ip池中选择一个合适的ip地址]
  3. [对ip地址进行检查，避免ip冲突，检查的方式有ARP探测和Ping]，前者是广播一个ARP请求，询问是否有人的ip为选择ip，后者是直接向该ip发送数据包，如果有应答则说明被占用。
  4. 最后[短暂标记该ip为被占用]，如果客户端在一定时间内没用Request确认，则会被回收
> DHCP会通过单播或广播的方式将Offer报文发送给请求客户端
- 单播是默认且首选的方式，只有在单播用不了的情况下，才会使用广播
> Offer消息包含若干必需字段和可选字段
 - `yiadd`（your ip address）：分配的ip
 - `siadd`（server ip address）：服务器的ip（也有在`Option54`中返回的）
 - `xid`：与Discover中的一致
 - `chaddr`： 客户端的 MAC 地址
 - `DHCP 服务器标识符` ：由siadd充当
- [可选字段则是按照客户端的需求返回的]，如DNS，网关，掩码等
> 多DHCP场景下，每个DHCP服务器都会发送一份Offer给请求客户端
> 客户端监听68号端口，接收Offer后会检查XID和chaddr，确保是自己的Offer
> 多Offer的情况下，通常会选择第一个，然后广播DHCP Request消息
### Request过程
> Request消息用于响应提供ip的服务器，同时通知其他服务器回收ip
- 当客户端成功接收并解析了至少一个有效的 DHCP Offer 消息，并决定接受其中一个（通常是最先到达的那个）后，它会立即广播 DHCP Request 消息。
> Request消息的发送与Discover类似，都是泛洪Request消息
- 值得注意的是，此时客户端还没能够正式使用这个被分配ip，因此其还是从0.0.0.0泛洪
> Request消息包含若干供服务器识别的字段
- `XID`：明确仍然是这次特定的 DORA 会话
- `Server Identifier（option54）`：客户端选择的服务器
- `Requested IP Address `：正式请求使用的ip地址
- `客户端标识符`：明确请求客户端
- `请求参数列表`：如果会话有请求其他参数，则需要对这些参数进行返回
> 其他未被选中的服务器会根据Option54得知自己未被选中，便立即释放ip，被选中服务器则着手发送ACK或NCK消息
### ACK
> ACK与NAK分别是服务器对客户端正式请求的批准与拒绝
- ACK的条件是`Server Identifier正确`，`ip仍然可用`，`仍然处于合法子网`；NAK的原因是`ip不可用`，或不处于合法子网等
> ACK的`发送`和`接收`与和Offer方法与消息内容相同，区别是Option53 DHCP message Type 设置为ACK（5）
- 在接收网络信息后，客户端会将接收到的 IP 地址、子网掩码、默认网关、DNS 服务器等信息配置到网络接口
### ARP探测
>客户端接收到ACK后，会广播发送免费ARP报文，探测本网段是否有其他终端使用服务器分配的IP地址，
- 如果在指定时间内没有收到回应，表示客户端可以使用此地址。如果收到了回应，说明有其他终端使用了此地址，客户端会向服务器发送`DHCP Decline`
### NAK
> NAK通过广播的方式，将NAK信息返回给客户端
> NAK包含若干字段，解释NAK的来源和原因
`Option 53`： DHCP Message Type - 设置为 NAK (值为 6)。明确标识这是一个 NAK 消息。
`Option 54`： DHCP Server Identifier - DHCP 服务器标识符 (必需，指明哪个服务器发的 NAK)。
`Option 56`： Message - 可选的文本消息 (可包含简短的拒绝原因，如 "Requested address not available" 或 "Client moved to new subnet")。客户端可能显示给用户或记录日志。
### ip的续租和回收
> 客户端会分别在租期还有1/2，1/4，1/8时发送request报文，如果收到ACK，则回满，三次都没收到则回收ip

# DHCP中继代理
## DHCP中继代理概念
> DHCP中继代理是实现DHCP客户端和DHCP服务器跨子网通信的技术
- 通过DHCP的学习，我们知道，其服务的范围在路由器内，当客户端和DHCP服务器在不同网段时，广播的Request请求会被路由器阻挡，因为[路由器默认不会转发广播包]
- 我们以一个实际的情景在看这个问题，例如一个公司的DHCP在某一个子网，而不同部门又被划分进不同的子网中，这就是一个典型的，DHCP需要跨子网服务的例子。
## DHCP中继代理的工作过程
> DHCP中继代理部署在路由器，将DHCP广播包转为指向目标DHCP服务器的单播包
- 中继代理对DHCP广播包的改造涉及以下方面：
  1. [源地址变为中继代理接收广播包的端口的ip]
  2. [目标地址变为提前配置好的一台或多态DHCP服务器的ip地址]
  3. [修改giaddr，填入中继代理接收到广播包的那个接口的 IP 地址]
  4. [单播转发]
> 远程DHCP服务器收到DHCP单播包后，会识别请求客户端所在的子网并构造Offer或ACK/NAK消息返回中继代理
- 远程DHCP服务器通过giaddr字段识别请求客户端所在的子网
- 服务器构造 DHCP Offer 或 DHCP ACK 响应。
- 服务器将信息返回giaddr中的地址
> 中继代理接收到返回的消息后，会广播/单播消息返回客户端
- 中继代理查看包内信息（如客户端的 MAC 地址）并将响应包的目标 IP 地址[改为255.255.255.255] 或客户端的 IP 地址（如果是 ACK），或者改为客户端的 MAC 地址（在二层）。
# TCP&UDP套接字编程
## 什么是socket
> 应用层的网络应用通过socket api的方式访问传输服务
- 其中，socket就是SAP，api就是原语。这个socket能够让人充分体会到语言的无力。从理论上来说
> socket是抽象并封装了底层复杂的网络协议栈（传输层 TCP/UDP，网络层 IP）和硬件操作，存储相关数据（ip，端口等）的数据结构。
- 这个所谓的底层复杂网络协议栈属于操作系统的范畴，不在计算机网络的学习范围内，因此我们只需要知道，socket将操作系统提供的网络功能以一种更简化，更抽象的方式进行呈现，同时维护一个四元/二元的数据表即可。
## C/S模型中的socket
### 服务器：
> 服务器首先创建一个监听socket，同时标明其为TCPsocket还是UDPsocket
- int server_fd = `socket`(AF_INET, SOCK_STREAM, 0);
> 绑定服务器地址和端口
- `bind`(server_fd, (struct sockaddr*)&server_addr, sizeof(server_addr));
> 开始监听该端口，等待建立连接
- `listen`(server_fd, 5);
> 监听进程阻塞，直到客户端与其建立TCP连接，其返回新的套接字
- int client_fd = `accept`(server_fd, (struct sockaddr*)&client_addr, &addr_len);
- [这个新的套接字被称为通信套接字]
### 客户端：
> 创建socket
> 服务器向客户端发起连接请求：
- `connect`(client_fd, (struct sockaddr*)&server_addr, sizeof(server_addr));
### 双方信息交流：
> 双方通过recv()/send() 或 read()/write()进行数据传输
> 最后关闭连接，通信套接字无效，但是监听套接字一直守候在端口等待下一次连接请求
- 也就是说，服务器将`监听`和`服务`的工作分离,这是理所当然的。
## UDP套接字编程
> UDP在TCP的基础上省略 listen()/accept()/connect()直接使用 sendto() 和 recvfrom() 指定目标地址：