# C语言的变量与常量
> c语言变量使用前必须声明
*代码*
int a b ;
[数据类型] [变量名1] [变量名2]；
> 变量名禁止特殊符号（除了_），禁止数字开头，禁止使用C语言保留关键字，区分大小写，只识别63个字符
> C语言通过赋值符：= 将右侧数值赋给左侧·  
- [C语言不存在赋值语句，赋值任务实际上是通过赋值符来完成的]
> 多重变量赋值
*代码*
int a , b = 1 , 2 ;
[数据类型] [变量名1]，[变量名2].....
- [该语句是表达式语句，因为其使用了一个运算符]
> 常量是程序中，不会发生改变的量。
> 变量的初始化
[变量的初始化指的是为变量赋予一个初始值的过程]
- 我们都知道，根据冯诺依曼模型，数据和指令都以二进制的形式存储在存储器中，因此，[当我们声明一个变量，实际上就是预留内存空间的过程。这个内存空间存在一个地址，地址绑定变量这个字面量的容器]。[对变量进行初始化，实际上就是将字面量以二进制的形式存储进这个内存空间。当我们后续再调用变量时，实际上就是根据内存地址，从内存中读取这个字面量]，因此，当我们重新对变量赋值，地址实际上没有发生变化，而是存储新的字面量。我们可以通过这个代码理解：
int main() {
    int a = 10; // 声明并初始化，分配内存地址0x1000，存储10
    printf("Address: %p, Value: %d\n", &a, a);
    a = 20; // 重新赋值，地址不变，0x1000处的值变为20
    printf("Address: %p, Value: %d\n", &a, a);
    return 0;
}

# C语言的数据类型
- [计算机的三大基本组成：硬件，软件，数据]。计算机离不开数据。C语言中，关于数据的语法是怎么样的呢？
*代码*
#include <stdio.h>

int main(void)
{
    float weight;
    float value;
    printf("Are you worth your weight in platium?\n");
    printf("Let's check it out.\n");
    printf("please enter your weight in pounds: ");

    scanf("%f",&weight);
    value = 1700.0 *weight *14.5833;
    printf("your weight in platinum is worth $%2.f.\n",value);
}
- 在上面这个代码中，我们看见了新的数据类型：float。同时我们使用scanf实现了数据从键盘的输入。[对于计算机来说，数据输入，经过CPU指令（也就是我们每行的代码）的处理，最后重新输出到终端中。这体现了冯·诺伊曼模型的基本工作原理。从更抽象的角度来说，我们的代码实际上控制了UTM各个部件的运行，最后实现了一次计算]
- 从这里，我想你能体会到为什么说图灵机界定了计算机的基本工作方式，同时理解到编程语言为什么具有图灵完备性，因为实际上，[计算机也好，编程语言也罢，它们都实现了图灵机的功能——具有通用计算能力]
> 数据类型关键字：
- `整数`： int，long short unsigned
- `字符`： char
- `浮点`： float double long double 
- `布尔`： _Bool
- `虚数和复数`： float_complex，double_complex, longdouble_complex(虚数同理)
- [我们都知道，计算机以补码的形式存储整数，以IEEE754标准存储浮点数。因此，我们在使用数据类型时，务必要注意到存储规则对不同类型的数据带来的影响，同时，我们需要关注不同数据类型的差异，与同一数据类型的不同关键字的差异]
- [对于C语言来说（以及大多数编程语言），7和7.0是两个不同的数据，前者是整数，后者是浮点数。]
## 整数类型
> int类型是有符号整型，意味着其为补码表示法，其可用范围为-2,147,483,648 到 2,147,483,647
- 根据补码的规则，我们可以得到在32位下的int表示范围。c语言标准规定的范围是基于较老的16位计算机，或嵌入式的16位计算机
> short，long，longlong与int类似，范围不同，都是有符号的
- [值得注意的是，longlong是至少64位的，long至少是32位的，其他是至少16位]
> 在C语言中，默认为int类型，在数字后添加l或L则表明其为long类型，ll或LL则为longlong类型
> 使用其他进制需加上对应的前缀，0b，0，0x分别是2 8 16进制的前缀
*代码*：
    int num1 = 0xACF;
    int num2 = 0b00110011;
    int num3 = 03476;
    printf("%d,%d,%d",num1,num2,num3);
- 输出结果为：2767,51,1854
> unsigned 是无符号整数
- [无符号整数的表示范围更大，因为其不需要使用一位来表示符号，因此其直接就是2的n次方而不需要-1]
> 根据实际需求选择合适的数据类型
## 溢出
> 在使用整数类型时，要注意溢出问题
- [根据计算机科学导论的知识，我们知道当数字超过了其能表示的范围时，就会发生溢出，在C语言中也是类似的，尝试执行下面的程序：]
#include <stdio.h>

int main(void)
{
    int i =2147483647;
    unsigned int j = 4294967295;
    printf("%d,%d,%d\n",i,i+1,i+2);
    printf("%u,%u,%u",j,j+1,j+2);
}
## 字符类型
> char类型用于存储字符，其本质是整数类型
- [值得注意的是，字符和字符串使用的符号不同，''才是字符]
- [根据数据存储的知识，我们知道计算机通过编码的方式存储文字，常用的编码方式是ASCII和Unicode。也就是说，对于计算机来说，字符的本质实际上是数字。在C语言中，char类型也可以赋值数字，但对可移植性有害，因为你不知道另一台计算机是ASCII还是Unicode]
- [当我们用char类型存储整数，需要区分其为有符号还是无符号，而这根据不同的编译器是不同的。我们可以通过指定chr是signed还是unsigned来规定其是有符号还是无符号]
*代码*
    char A;
    A = 100;
    printf("%c",A);
    printf("%d",A) 
- 最终的输出结果是字符d 和数字100
- [c语言是弱类型语言，也就是不严格区分变量类型，存在隐式变量类型转换，不论字面量是字符还是数字，其最后取决于使用的转换符]
> 一些特殊的字符有其特殊的写法
  1. \n 是我们已经熟练的，称为换行符
  2. \b \r \t \0 \? (退格：删除前一个字符)（回车符，回到行首）（生成水平制表符）（空字符） (问号)
  3. \0oo \xhh （八进制ASCII转义，十六进制ASCII转义）
- [这些特殊字符被称为转义符,你可以通过赋值将它们赋值给字符变量，但是一般转义符只在字符串中才能看出效果]
## 布尔类型
> _bool类型用于存储布尔值
- [在C语言中，True为1，False为0]
## 浮点数类型
> float 根据IEEE 754单精度浮点数表示法存储浮点数，而double以双精度存储，因此double的范围比float要大
> 在C语言中，一个浮点数如2E5或.3默认被视为double，如果在数字后加上f，则被视为float（单精）加上L，则为long double类型
- 根据IEEE754标准，单精度表示法的范围为(-2*2^127，-1*2^-126]U[1*2^-126，2*2^127）,超出这个范围会发生溢出，在C语言中，当一个浮点数超出当前类型能表示的范围后，使用inf来表示它，称为上溢
> 计算机在处理浮点数时，总是要考虑`精度有限`和`舍入误差`这两个问题
- [例如，float只保证6-7位小数点数字的精度，double只保证10位数字的精度，当赋值的浮点数位数过多，则计算结果一定是错误的]
- [同时，IEEE754本身也存在一定取舍，例如，有的小数的尾数是无限的，例如无限不循环小数，那么在有限的尾数存储位数下，我们实际只能得到近似值]
- [所以，假设一个浮点数原本是精准的，在进行运算时，如果涉及到尾数的调整，就有可能导致尾数超出有限尾数存储位数，IEEE754会进行截断或四舍五入，这被称为舍入误差]
*例子*
#include <stdio.h>

int main(void)
{
    float num1 =0.1;
    printf("%.10f\n",num1); /*输出：0.1000000015*/
    double num2 =0.1;
    printf("%.10f",num2);  /*输出：0.1000000000*/
}

## 数据类型大小
> 使用sizeof运算符可以求得数据类型的大小
 *代码*
int main(void)
{
    printf("the size of num1 is:%zd bytes.\n",sizeof(int)); 
    printf("the size of num1 is:%zd bytes.\n",sizeof(float));
    printf("the size of num1 is:%zd bytes.\n",sizeof(char));
    printf("the size of num1 is:%zd bytes.\n",sizeof(long));
    printf("the size of num1 is:%zd bytes.\n",sizeof(short));
    printf("the size of num1 is:%zd bytes.\n",sizeof(long long));
    printf("the size of num1 is:%zd bytes.\n",sizeof(double));
    printf("the size of num1 is:%zd bytes.\n",sizeof(long double));
    printf("the size of num1 is:%zd bytes.\n",sizeof(unsigned));
    printf("the size of num1 is:%zd bytes.\n",sizeof(unsigned long));
    printf("the size of num1 is:%zd bytes.\n",sizeof(unsigned short));
}
- [通过运行结果，我们不难看出：int和long都是32位，而short为16位，longlong为64位，这也验证了教材的那句话：int要么和long相同要么和int相同]
- [float是4位，double为8位，longdouble则为128位]
- [unsigned类型与有符号是一样的]
- [char的大小一定是1，这是C语言规定的]

# 基本输入与输出
## 输入
> scanf函数实现从标准输入（通常是键盘）读取格式化数据。
- scanf函数包含`格式化字符`和`指针传递`两部分。
**代码**
int num;
float f;
char ch;
char str[100];
scanf("%d", &num);        // 读取整数
scanf("%f", &f);          // 读取浮点数
scanf(" %c", &ch);        // 读取字符（空格跳过空白符）
scanf("%s", str);         // 读取字符串（遇空格/换行停止）
scanf("%d %f", &num, &f); // 读取多个值
> scanf需要注意缓冲区残留问题
- 在大多数系统中，标准输入是`行缓冲`的。这意味着[用户输入的字符不会立即被程序读取]，而是[先存储在缓冲区中]，直到按下回车键（即输入了一个换行符`\n`），整个输入行才被送入程序可访问的缓冲区
- scanf [从缓冲区头部开始读取数据，仅消耗匹配格式所需字符]。未使用的字符（如换行符 \n）保留在缓冲区中，影响后续输入操作
- 当`scanf`读取非字符数据（如`%d`）时，它会跳过前导空白符，读取所需数据，但将后续的换行符`\n`（用户按回车产生）留在缓冲区。这会影响后续的`%c`或`fgets`读取。
> scanf的参数传递是指针传递
- 在C语言中，函数[默认是值传递，值传递获得变量的副本，无法修改变量。因此需要加上&，传递变量的指针，通过指针传递，直接对变量所在内存进行修改]
## 输出
> printf 实现输出
- [C语言的prinf强制要求格式化输出，也就是通过含占位符的格式化字符串进行输出]
> 用\n刷新printf的缓冲区
-[printf语句最初会将数据发送到缓冲区，当缓冲区满，遇到换行符或需要输入时，才会将数据从缓冲区发送到终端。而有时，我们会遇到缓冲区没满，但是我们又希望内容被输出到终端的情况，因此在字符串后加上换行符是一个好的习惯] 
> printf 打印整数类型
int: %d 或 %i
short: %hd（h 表示 "short"）
long: %ld（l 表示 "long"）
long long: %lld（C99标准）
无符号整型：用 %u, %hu, %lu, %llu（对应不同长度的无符号类型）
八进制整数：%o 
小写十六进制整数：%x
显示前缀：%#x 
大写十六进制整数：%X	
- [说明符与linux命令的参数一样，是可以叠加的]
> printf 打印字符类型
%c 字符
八，十六进制转义：%c
> printf 打印浮点类型
float: %f
固定位数：%.10f
double: %f 或 %lf（printf 中 %f 和 %lf 等效）
long double: %Lf（L 必须大写）
e点计数法表示的浮点数：%e
十六进制浮点数 ：%a
> printf 打印字符类型
char: %c
> printf 打印布尔类型
%d [布尔值本质是0和1]   
> printf 打印转义符