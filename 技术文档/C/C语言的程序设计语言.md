# C的编译
> C的编译通过编译和链接来完成
- 我们在学习《FOCS》时提及编译的一大特点是如果程序出现问题，需要重新编译。[C的编译以更为巧妙地方式进行，其将程序分为若干个部分分别编译，然后用链接器将多个部分连接，避免了需要整个编译的繁琐]
> 链接器将库代码，启动代码，与目标代码连接在一起，生成可执行文件
- 启动代码：[可执行程序与操作系统的接口]
- 库代码：函数的代码集合，也就是说[目标代码不存储函数代码，而是从`库`中调用]

# C程序剖析
*代码*
```
# include <stdio.h>
int main void():
{
    function a  
}
{
    function b
}
```
> 函数是C语言的构造块，由语句构成
- C语言是面向过程语言，[面向过程语言程序的本质是过程触发和调用的集合]。而面向过程语言程序又可以分为：`对象创建部分`，`过程调用部分`，`过程定义部分`。而C语言将[对象的创建涵盖在过程定义部分]
> C语言的六种语句：
  1. 标号语句
  2. 复合语句
  3. 表达式语句
  4. 选择语句
  5. 迭代语句
  6. 跳转语句
- 我们在后续会结合具体的代码进行介绍

# 头文件
> 头文件是C语言的预处理文件
- 入门C语言的第一关，就是正确理解头文件。不少人都知道C语言的变量需要声明后，才能使用，但事实上C语言的`标准库函数`同样也需要声明！而[头文件包含了标准库函数的声明（不同函数对于不同的头文件）以及其他需要预先声明的东西。]
- ```# include```这一句实现了[将头文件内对标准库函数的声明复制到源文件]，然后才进行编译。这就有点类似于在python中使用常用包需要import语句导入包
> 分层解耦+显式链接是C语言的特点
- 值得注意的是，[头文件不包括标准库函数的定义代码]！[函数的定义代码保存在标准库库中]。本质上来说，[C语言将一门高级编程语言的重要部分独立封装，而头文件只是个接口。对于C语言来说，内置函数和编译器都是独立的，彼此通过链接器重整后，才成为一个可执行程序]

# 两个关于可移植性的头文件
> stdint.h头文件定义了固定宽度的整数类型，确保代码在不同平台上有统一的内存占用
> inttypes.h头文件提供与这些类型匹配的 printf/scanf 格式说明符（如 PRId32）
- [两个头文件增强了C语言程序的可移植性]

# main函数
> main函数是程序入口点
- [链接器在生成可执行文件时，会默认寻找名为main的符号作为入口]，因此程序的第一个函数一定要叫main
- 从本质上来讲，[操作系统执行可执行文件需要一个起始点]，这个起始点被称为main实际上是[约定俗成]的. 
# 函数格式
> 函数由函数头和函数体构成
> 函数头由`函数类型`和`函数名`构成
标准函数头由：
`返回值类型` `函数名` `(参数列表)`构成,参数可以是各种数据类型，且必须显式声明
`例如int main（）中，int是函数类型，意味着函数范围数字，main是函数名, 对于main函数来说，函数返回值类型一定是int`
> 函数体由`花括号`和`被花括号包含的语句`构成，`大部分`语句必须在末尾加；
{
    语句1；
    语句2；
    语句3
}
- [括号里的是形式参数，形式参数只有在函数调用时才存储实际参数，因此无参数直接不填]
# 多函数声明
> 除mian函数外，其他函数在使用前必须显式声明
*代码*
#include <stdio.h>

void jolly(void);
void deny(void);

int main()
{
    jolly();
    jolly();
    jolly();
    deny();
    return 0;
}
void jolly(void)
{
    printf("For he's a jolly good fellow\n");
}

void deny(void)
{
    printf("Which nobody can deny");
}
- 我们将void jolly(void);称为[函数原型]，main里面的jolly()称为[函数调用]，void jolly(void)称为[函数定义]
- [与python类似，子函数的执行取决于其在主调函数中（主程序）中，函数调用的位置，而与函数定义的位置无关]

# 注释
> 注释由/* */ 包围

# C程序的标准格式
- [因此，对于一个c程序来说，其存在标准的格式：]
预处理指令 头文件
函数类型 函数名()
{
    语句；
    语句；
}

# C语言的变量与常量
> c语言变量使用前必须声明
*代码*
int a b ;
[数据类型] [变量名1] [变量名2]；
> 变量名禁止特殊符号（除了_），禁止数字开头，禁止使用C语言保留关键字，区分大小写，只识别63个字符
> C语言通过赋值符：= 将右侧数值赋给左侧·  
- [C语言不存在赋值语句，赋值任务实际上是通过赋值符来完成的]
> 多重变量赋值
*代码*
int a , b = 1 , 2 ;
[数据类型] [变量名1]，[变量名2].....
- [该语句是表达式语句，因为其使用了一个运算符]
> 常量是程序中，不会发生改变的量。
> 变量的初始化
[变量的初始化指的是为变量赋予一个初始值的过程]
- 我们都知道，根据冯诺依曼模型，数据和指令都以二进制的形式存储在存储器中，因此，[当我们声明一个变量，实际上就是预留内存空间的过程。这个内存空间存在一个地址，地址绑定变量这个字面量的容器]。[对变量进行初始化，实际上就是将字面量以二进制的形式存储进这个内存空间。当我们后续再调用变量时，实际上就是根据内存地址，从内存中读取这个字面量]，因此，当我们重新对变量赋值，地址实际上没有发生变化，而是存储新的字面量。我们可以通过这个代码理解：
int main() {
    int a = 10; // 声明并初始化，分配内存地址0x1000，存储10
    printf("Address: %p, Value: %d\n", &a, a);
    a = 20; // 重新赋值，地址不变，0x1000处的值变为20
    printf("Address: %p, Value: %d\n", &a, a);
    return 0;
}

# C语言的数据类型
- [计算机的三大基本组成：硬件，软件，数据]。计算机离不开数据。C语言中，关于数据的语法是怎么样的呢？
*代码*
#include <stdio.h>

int main(void)
{
    float weight;
    float value;
    printf("Are you worth your weight in platium?\n");
    printf("Let's check it out.\n");
    printf("please enter your weight in pounds: ");

    scanf("%f",&weight);
    value = 1700.0 *weight *14.5833;
    printf("your weight in platinum is worth $%2.f.\n",value);
}
- 在上面这个代码中，我们看见了新的数据类型：float。同时我们使用scanf实现了数据从键盘的输入。[对于计算机来说，数据输入，经过CPU指令（也就是我们每行的代码）的处理，最后重新输出到终端中。这体现了冯·诺伊曼模型的基本工作原理。从更抽象的角度来说，我们的代码实际上控制了UTM各个部件的运行，最后实现了一次计算]
- 从这里，我想你能体会到为什么说图灵机界定了计算机的基本工作方式，同时理解到编程语言为什么具有图灵完备性，因为实际上，[计算机也好，编程语言也罢，它们都实现了图灵机的功能——具有通用计算能力]
> 数据类型关键字：
- `整数`： int，long short unsigned
- `字符`： char
- `浮点`： float double long double 
- `布尔`： _Bool
- `虚数和复数`： float_complex，double_complex, longdouble_complex(虚数同理)
- [我们都知道，计算机以补码的形式存储整数，以IEEE754标准存储浮点数。因此，我们在使用数据类型时，务必要注意到存储规则对不同类型的数据带来的影响，同时，我们需要关注不同数据类型的差异，与同一数据类型的不同关键字的差异]
- [对于C语言来说（以及大多数编程语言），7和7.0是两个不同的数据，前者是整数，后者是浮点数。]
## 整数类型
> int类型是有符号整型，意味着其为补码表示法，其可用范围为-2,147,483,648 到 2,147,483,647
- 根据补码的规则，我们可以得到在32位下的int表示范围。c语言标准规定的范围是基于较老的16位计算机，或嵌入式的16位计算机
> short，long，longlong与int类似，范围不同，都是有符号的
- [值得注意的是，longlong是至少64位的，long至少是32位的，其他是至少16位]
> 在C语言中，默认为int类型，在数字后添加l或L则表明其为long类型，ll或LL则为longlong类型
> 使用其他进制需加上对应的前缀，0b，0，0x分别是2 8 16进制的前缀
*代码*：
    int num1 = 0xACF;
    int num2 = 0b00110011;
    int num3 = 03476;
    printf("%d,%d,%d",num1,num2,num3);
- 输出结果为：2767,51,1854
> unsigned 是无符号整数
- [无符号整数的表示范围更大，因为其不需要使用一位来表示符号，因此其直接就是2的n次方而不需要-1]
> 根据实际需求选择合适的数据类型
## 溢出
> 在使用整数类型时，要注意溢出问题
- [根据计算机科学导论的知识，我们知道当数字超过了其能表示的范围时，就会发生溢出，在C语言中也是类似的，尝试执行下面的程序：]
#include <stdio.h>

int main(void)
{
    int i =2147483647;
    unsigned int j = 4294967295;
    printf("%d,%d,%d\n",i,i+1,i+2);
    printf("%u,%u,%u",j,j+1,j+2);
}
## 字符类型
> char类型用于存储字符，其本质是整数类型
- [值得注意的是，字符和字符串使用的符号不同，''才是字符]
- [根据数据存储的知识，我们知道计算机通过编码的方式存储文字，常用的编码方式是ASCII和Unicode。也就是说，对于计算机来说，字符的本质实际上是数字。在C语言中，char类型也可以赋值数字，但对可移植性有害，因为你不知道另一台计算机是ASCII还是Unicode]
- [当我们用char类型存储整数，需要区分其为有符号还是无符号，而这根据不同的编译器是不同的。我们可以通过指定chr是signed还是unsigned来规定其是有符号还是无符号]
*代码*
    char A;
    A = 100;
    printf("%c",A);
    printf("%d",A) 
- 最终的输出结果是字符d 和数字100
- [c语言是弱类型语言，也就是不严格区分变量类型，存在隐式变量类型转换，不论字面量是字符还是数字，其最后取决于使用的转换符]
> 一些特殊的字符有其特殊的写法
  1. \n 是我们已经熟练的，称为换行符
  2. \b \r \t \0 \? (退格：删除前一个字符)（回车符，回到行首）（生成水平制表符）（空字符） (问号)
  3. \0oo \xhh （八进制ASCII转义，十六进制ASCII转义）
- [这些特殊字符被称为转义符,你可以通过赋值将它们赋值给字符变量，但是一般转义符只在字符串中才能看出效果]
## 布尔类型
> _bool类型用于存储布尔值
- [在C语言中，True为1，False为0]
## 浮点数类型
> float 根据IEEE 754单精度浮点数表示法存储浮点数，而double以双精度存储，因此double的范围比float要大
> 在C语言中，一个浮点数如2E5或.3默认被视为double，如果在数字后加上f，则被视为float（单精）加上L，则为long double类型
- 根据IEEE754标准，单精度表示法的范围为(-2*2^127，-1*2^-126]U[1*2^-126，2*2^127）,超出这个范围会发生溢出，在C语言中，当一个浮点数超出当前类型能表示的范围后，使用inf来表示它，称为上溢
> 计算机在处理浮点数时，总是要考虑`精度有限`和`舍入误差`这两个问题
- [例如，float只保证6-7位小数点数字的精度，double只保证10位数字的精度，当赋值的浮点数位数过多，则计算结果一定是错误的]
- [同时，IEEE754本身也存在一定取舍，例如，有的小数的尾数是无限的，例如无限不循环小数，那么在有限的尾数存储位数下，我们实际只能得到近似值]
- [所以，假设一个浮点数原本是精准的，在进行运算时，如果涉及到尾数的调整，就有可能导致尾数超出有限尾数存储位数，IEEE754会进行截断或四舍五入，这被称为舍入误差]
*例子*
#include <stdio.h>

int main(void)
{
    float num1 =0.1;
    printf("%.10f\n",num1); /*输出：0.1000000015*/
    double num2 =0.1;
    printf("%.10f",num2);  /*输出：0.1000000000*/
}

## 数据类型大小
> 使用sizeof运算符可以求得数据类型的大小
 *代码*
int main(void)
{
    printf("the size of num1 is:%zd bytes.\n",sizeof(int)); 
    printf("the size of num1 is:%zd bytes.\n",sizeof(float));
    printf("the size of num1 is:%zd bytes.\n",sizeof(char));
    printf("the size of num1 is:%zd bytes.\n",sizeof(long));
    printf("the size of num1 is:%zd bytes.\n",sizeof(short));
    printf("the size of num1 is:%zd bytes.\n",sizeof(long long));
    printf("the size of num1 is:%zd bytes.\n",sizeof(double));
    printf("the size of num1 is:%zd bytes.\n",sizeof(long double));
    printf("the size of num1 is:%zd bytes.\n",sizeof(unsigned));
    printf("the size of num1 is:%zd bytes.\n",sizeof(unsigned long));
    printf("the size of num1 is:%zd bytes.\n",sizeof(unsigned short));
}
- [通过运行结果，我们不难看出：int和long都是32位，而short为16位，longlong为64位，这也验证了教材的那句话：int要么和long相同要么和int相同]
- [float是4位，double为8位，longdouble则为128位]
- [unsigned类型与有符号是一样的]
- [char的大小一定是1，这是C语言规定的]

# 输入与输出
## 输入
> scanf函数输入
> getchar函数输入
> fgets函数输入

## 输出
> printf 实现输出
- [C语言的prinf强制要求格式化输出，也就是通过含占位符的格式化字符串进行输出]
> 用\n刷新printf的缓冲区
-[printf语句最初会将数据发送到缓冲区，当缓冲区满，遇到换行符或需要输入时，才会将数据从缓冲区发送到终端。而有时，我们会遇到缓冲区没满，但是我们又希望内容被输出到终端的情况，因此在字符串后加上换行符是一个好的习惯] 
> printf 打印整数类型
int: %d 或 %i
short: %hd（h 表示 "short"）
long: %ld（l 表示 "long"）
long long: %lld（C99标准）
无符号整型：用 %u, %hu, %lu, %llu（对应不同长度的无符号类型）
八进制整数：%o 
小写十六进制整数：%x
显示前缀：%#x 
大写十六进制整数：%X	
- [说明符与linux命令的参数一样，是可以叠加的]
> printf 打印字符类型
%c 字符
八，十六进制转义：%c
> printf 打印浮点类型
float: %f
double: %f 或 %lf（printf 中 %f 和 %lf 等效）
long double: %Lf（L 必须大写）
e点计数法表示的浮点数：%e
十六进制浮点数 ：%a
> printf 打印字符类型
char: %c
> printf 打印布尔类型
%d [布尔值本质是0和1]   
> printf 打印转义符
